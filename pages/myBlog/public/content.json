{"meta":{"title":"Lemon","subtitle":"Lemonの博客","description":"本科 | 计算机科学与技工程 | 数字媒体技术","author":"Leomn","url":"https://lemonsama123.gitee.io","root":"/"},"pages":[{"title":"","date":"2022-01-09T02:07:58.364Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://lemonsama123.gitee.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://lemonsama123.gitee.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-01-09T02:07:58.365Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://lemonsama123.gitee.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://lemonsama123.gitee.io/about/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://lemonsama123.gitee.io/census/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://lemonsama123.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://lemonsama123.gitee.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://lemonsama123.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"contact/index.html","permalink":"https://lemonsama123.gitee.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://lemonsama123.gitee.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://lemonsama123.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://lemonsama123.gitee.io/resource/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://lemonsama123.gitee.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://lemonsama123.gitee.io/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://lemonsama123.gitee.io/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-01-09T02:07:58.366Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-01-09T02:07:58.367Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://lemonsama123.gitee.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"算法提高","slug":"算法提高","date":"2022-04-23T15:10:35.000Z","updated":"2022-04-23T15:10:35.064Z","comments":true,"path":"posts/30fef56b.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/30fef56b.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"算法进阶","slug":"算法进阶","date":"2022-04-23T15:10:32.000Z","updated":"2022-04-23T15:10:32.596Z","comments":true,"path":"posts/5469c363.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/5469c363.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"算法基础","slug":"算法基础","date":"2022-04-23T15:10:29.000Z","updated":"2022-04-24T00:27:16.768Z","comments":true,"path":"posts/fa1802cb.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/fa1802cb.html","excerpt":"","text":"一、基础算法1.1 排序1.2 二分1.3 高精度1.4 前缀和与差分1.5 双指针算法1.6 位运算1.7 离散化1.8 区间合并二、数据结构2.1 链表与邻接表：树与图的存储2.2 栈与队列：单调队列、单调栈2.3 kmp2.4 Trie2.5 并查集2.6 堆2.7 Hash表三、搜索与图论3.1 DFS与BFS3.2 树与图的遍历：拓扑排序3.3 最短路3.4 最小生成树3.5 二分图：染色法、匈牙利算法四、数学知识4.1 质数4.2 约数欧拉函数快速幂扩展欧几里得算法中国剩余定理高斯消元组合计数容斥原理简单博弈论 五、动态规划背包问题线性DP区间DP计数类DP数位统计DP状态压缩DP树形DP记忆化搜索 六、贪心七、时空复杂度分析","categories":[],"tags":[]},{"title":"图算法","slug":"图算法","date":"2022-04-01T05:01:20.000Z","updated":"2022-04-07T15:19:51.186Z","comments":true,"path":"posts/922ba922.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/922ba922.html","excerpt":"","text":"一、图的基本概念及名词解释二、图的表示这里所说的图的表示指的是图的存储结构。 笔者在刷题过程中遇到过的表示方法有三种：邻接矩阵、邻接表、边集数组和类，其中邻接矩阵、邻接表和类是我们在写算法是会用到的，有时候题目会以边集数组的形式给出数据，我们应当将其转换为邻接矩阵、邻接表或类。 为了方便，约定：$N$ 为点数， $M$ 为边数。 有向图一般使用 $G$ 表示，无向图一般使用 $E$ 表示 2.1 邻接矩阵这是一种使用二维矩阵来进行存图的方式。 适用于边数较多的稠密图使用，当边数量接近点的数量的平方，即 $M \\approx N^{2}$ 是，定义为稀疏图。 下面分别介绍无权无向图、无权有向图、带权无向图和带权有向图的邻接矩阵。 2.1.1 无权无向图的邻接矩阵$$A[i][j] = \\left\\lbrace\\begin{array}{ll}1, &amp;(v_{i}, v_{j}) \\in E \\newline0 ,&amp; (v_{i}, v_{j}) \\notin G\\end{array}\\right.$$ 例如下面的图： 其邻接矩阵为： 2.1.2 无权有向图的邻接矩阵$$A[i][j] = \\left\\lbrace\\begin{array}{ll}1, &amp; &lt;v_{i}, v_{j}&gt; \\in G \\newline0 ,&amp; &lt;v_{i}, v_{j}&gt;\\notin G\\end{array}\\right.$$ 2.1.3 带权无向图的邻接矩阵$$A[i][j] = \\left\\lbrace\\begin{array}{ll}W_{ij} , &amp; (v_{i}, v_{j}) \\in E \\newline0 ,&amp; i = j \\newline\\infty, &amp; \\text{其他}\\end{array}\\right.$$ 2.1.4 带权有向图的邻接矩阵$$A[i][j] = \\left\\lbrace\\begin{array}{ll}W_{ij} , &amp; &lt;v_{i}, v_{j}&gt; \\in E \\newline0 ,&amp; i = j \\newline\\infty, &amp; \\text{其他}\\end{array}\\right.$$ 2.2 邻接表2.3 边集数组2.4 类三、并查集3.1 Quick Find 并查集public class UnionFind { int root[]; public UnionFind(int size) { root = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; } } public int find(int x) { return root[x]; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { for (int i = 0; i &lt; root.length; i++) { if (root[i] == rootY) { root[i] = rootX; } } } }; public boolean connected(int x, int y) { return find(x) == find(y); } } 3.2 Quick Union 并查集public class UnionFind { int root[]; public UnionFind(int size) { root = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; } } public int find(int x) { while (x != root[x]) { x = root[x]; } return x; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { root[rootY] = rootX; } }; public boolean connected(int x, int y) { return find(x) == find(y); } } 3.3 按秩合并的并查集public class UnionFind { int root[]; int rank[]; public UnionFind(int size) { root = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; rank[i] = 1; } } public int find(int x) { while (x != root[x]) { x = root[x]; } return x; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] &gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] &lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } }; public boolean connected(int x, int y) { return find(x) == find(y); } } 3.4 路径压缩优化的并查集public class UnionFind { int root[]; public UnionFind(int size) { root = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; } } public int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { root[rootY] = rootX; } }; public boolean connected(int x, int y) { return find(x) == find(y); } } 3.5 图论算法中用到的并查集的最终版本public class UnionFind { int root[]; int rank[]; public UnionFind(int size) { root = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; rank[i] = 1; } } public int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] &gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] &lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } }; public boolean connected(int x, int y) { return find(x) == find(y); } } public class Main { static int root[]; static int rank[]; public static void init(int size) { root = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; rank[i] = 1; } } public static int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } public static void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] &gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] &lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } }; public static boolean connected(int x, int y) { return find(x) == find(y); } } 3.6 并查集的几道题leetcode 547. 省份数量 poj 1182. 食物链 四、DFS 和 BFS没什么好说的。 五、最小生成树最小生成树算法用于带权无向图，主要有两种：Prim 算法和 Kruskal 算法。 5.1 Prim 算法import java.util.Arrays; public class Main { public int prim(int[][] points) { if (points == null || points.length == 0) { return 0; } int N = points.length; int[][] adjacencyMatrix = new int[N][N]; for (int i = 0; i &lt; N; i++) { for (int j = i + 1; j &lt; N; j++) { adjacencyMatrix[i][j] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]); adjacencyMatrix[j][i] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]); } } boolean[] visited = new boolean[N]; int[] minCost = new int[N]; Arrays.fill(minCost, Integer.MAX_VALUE); visited[0] = true; for (int i = 1; i &lt; N; i++) {//初始化一下其他顶点与第一个顶点的距离 minCost[i] = adjacencyMatrix[i][0]; } int res = 0; for (int i = 1; i &lt; N; i++) { int minIndex = -1; int minValue = Integer.MAX_VALUE; for (int j = 0; j &lt; N; j++) { if (visited[j]) { continue; } if (minCost[j] &lt; minValue) { minIndex = j; minValue = minCost[j]; } } if (minIndex == -1) { break; } res += minValue; visited[minIndex] = true; minCost[minIndex] = -1; for (int j = 0; j &lt; N; j++) { if (!visited[j] &amp;&amp; adjacencyMatrix[j][minIndex] &lt; minCost[j]) { minCost[j] = adjacencyMatrix[j][minIndex]; } } } return res; } } Prim 算法的另外一种模板： import java.util.Comparator; import java.util.PriorityQueue; public class Main { public int prim(int[][] points) { if (points == null || points.length == 0) { return 0; } int size = points.length; PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(x -&gt; x.cost)); boolean[] visited = new boolean[size]; int result = 0; int count = size - 1; for (int j = 1; j &lt; size; j++) { int[] coordinate1 = points[0]; int[] coordinate2 = points[j]; int cost = Math.abs(coordinate1[0] - coordinate2[0]) + Math.abs(coordinate1[1] - coordinate2[1]); Edge edge = new Edge(0, j, cost); pq.add(edge); } visited[0] = true; while (pq.size() &gt; 0 &amp;&amp; count &gt; 0) { Edge e = pq.poll(); int point1 = e.point1; int point2 = e.point2; int cost = e.cost; if ( !visited[point2] ) { result += cost; visited[point2] = true; for (int j = 0; j &lt; size; j++ ) { if ( !visited[j] ) { int distance = Math.abs(points[point2][0] - points[j][0]) + Math.abs(points[point2][1] - points[j][1]); pq.add(new Edge(point2, j, distance)); } } count--; } } return result; } } class Edge { int point1; int point2; int cost; Edge(int point1, int point2, int cost) { this.point1 = point1; this.point2 = point2; this.cost = cost; } } 5.2 Kruskal 算法import java.util.Comparator; import java.util.PriorityQueue; public class Kruskal { int[] root; int[] rank; public void init(int size) { root = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; rank[i] = 1; } } public int find(int x) { if (x == root[x]) { return x; } root[x] = find(root[x]); return root[x]; } public void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] &gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] &lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; ++rank[rootX]; } } } public boolean connected(int x, int y) { return find(x) == find(y); } //points 是以边集数组的形式输入 public int kruskal(int[][] edges) { int n = edges.length; PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o.cost)); for (int i = 0; i &lt; n; i++) { int from = edges[i][0]; int to = edges[i][1]; int cost = edges[i][2]; priorityQueue.offer(new Edge(from, to, cost)); } init(n); int count = n - 1; int ans = 0; while (!priorityQueue.isEmpty() &amp;&amp; count != 0) { Edge curEdge = priorityQueue.poll(); if (!connected(curEdge.from, curEdge.to)) { union(curEdge.from, curEdge.to); --count; ans += curEdge.cost; } } return ans; } } class Edge { int from; int to; int cost; public Edge(int from, int to, int cost) { this.from = from; this.to = to; this.cost = cost; } } 5.3 最小生成树的几道题leetcode 1584. 连接所有点的最小费用 poj 1789. Truck History poj 2485. Highways poj 1258. Agri-Net import java.util.Arrays; import java.util.Scanner; //直接使用邻接矩阵的 prim public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int n = sc.nextInt(); int[][] graph = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { graph[i][j] = sc.nextInt(); } } int result = prim(graph); System.out.println(result); } } public static int prim(int[][] graph) { int N = graph.length; boolean[] visited = new boolean[N]; int[] minCost = new int[N]; Arrays.fill(minCost, Integer.MAX_VALUE); visited[0] = true; for (int i = 0; i &lt; N; i++) { if (i == 0) { continue; } minCost[i] = graph[i][0]; } int res = 0; for (int i = 1; i &lt; N; i++) { int minIdx = -1; int minVal = Integer.MAX_VALUE; for (int j = 0; j &lt; N; j++) { if (visited[j]) { continue; } if (minCost[j] &lt; minVal) { minIdx = j; minVal = minCost[j]; } } res += minVal; visited[minIdx] = true; minCost[minIdx] = -1; for (int j = 0; j &lt; N; j++) { if (!visited[j] &amp;&amp; graph[j][minIdx] &lt; minCost[j]) { minCost[j] = graph[j][minIdx]; } } } return res; } } import java.util.PriorityQueue; import java.util.Scanner; //使用类+优先级队列的kruskal public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int n = sc.nextInt(); int[][] graph = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { graph[i][j] = sc.nextInt(); } } int result = kruskal(graph); System.out.println(result); } } public static int kruskal(int[][] edges) { int n = edges.length; PriorityQueue&lt;Edge&gt; priorityQueue = new PriorityQueue&lt;Edge&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { int from = i; int to = j; int cost = edges[i][j]; priorityQueue.offer(new Edge(from, to, cost)); } } init(n); int count = n - 1; int ans = 0; while (!priorityQueue.isEmpty() &amp;&amp; count != 0) { Edge curEdge = priorityQueue.poll(); if (!connected(curEdge.from, curEdge.to)) { union(curEdge.from, curEdge.to); --count; ans += curEdge.cost; } } return ans; } static int[] root; static int[] rank; public static void init(int size) { root = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) { root[i] = i; rank[i] = 1; } } public static int find(int x) { if (x == root[x]) { return x; } root[x] = find(root[x]); return root[x]; } public static void union(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] &gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] &lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; ++rank[rootX]; } } } public static boolean connected(int x, int y) { return find(x) == find(y); } } import java.util.PriorityQueue; import java.util.Scanner; /** * 使用类+优先级队列的prim * 相较于朴素prim，实现较为简单 */ public class Main3 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int n = sc.nextInt(); int[][] graph = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { graph[i][j] = sc.nextInt(); } } int result = prim(graph); System.out.println(result); } } public static int prim(int[][] graph) { if (graph == null || graph.length == 0) { return 0; } int size = graph.length; PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;Edge&gt;(); boolean[] visited = new boolean[size]; int result = 0; int count = size - 1; for (int i = 1; i &lt; size; i++) { int cost = graph[0][i]; Edge edge = new Edge(0, i, cost); pq.add(edge); } visited[0] = true; while (pq.size() &gt; 0 &amp;&amp; count &gt; 0) { Edge e = pq.poll(); int point1 = e.from; int point2 = e.to; int cost = e.cost; if ( !visited[point2] ) { result += cost; visited[point2] = true; for (int j = 0; j &lt; size; j++ ) { if (!visited[j]) { int distance = graph[point2][j]; pq.add(new Edge(point2, j, distance)); } } count--; } } return result; } } 六、最短路径七、拓扑排序7.1 AOV 网和拓扑排序简介八、关键路径8.1 AOE 网和关键路径简介九、参考 数据结构：图Graph【详解】 一张图看懂数据结构——图 【宫水三叶】涵盖所有的「存图方式」与「最短路算法（详尽注释）」 Prim and Kruskal leetbook《图》 poj 《算法》第四版","categories":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图","slug":"图","permalink":"https://lemonsama123.gitee.io/tags/%E5%9B%BE/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://lemonsama123.gitee.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"https://lemonsama123.gitee.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"AOV","slug":"AOV","permalink":"https://lemonsama123.gitee.io/tags/AOV/"},{"name":"AOE","slug":"AOE","permalink":"https://lemonsama123.gitee.io/tags/AOE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://lemonsama123.gitee.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"关键路径","slug":"关键路径","permalink":"https://lemonsama123.gitee.io/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"},{"name":"并查集","slug":"并查集","permalink":"https://lemonsama123.gitee.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"author":"Lemon"},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2022-03-01T01:25:30.000Z","updated":"2022-04-11T13:16:23.306Z","comments":true,"path":"posts/8d4b7ae1.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/8d4b7ae1.html","excerpt":"","text":"第一章 计算机系统概述1.1 计算机发展历程1.1.1 国外计算机发展状况 电子管计算机（1946——1958年）：第一代计算机的基本电子器件为电子管。 晶体管计算机（1958年——1964年）：第二代计算机的基本电子器件为晶体管。 集成电路计算机（1964年——1971年）：第三代计算机的基本电子器件普遍采用集成电路。 超大规模集成电路计算机（1971年至今）：第四代计算机普遍采用了超大规模集成电路，以微处理器为特征，运算速度从 MIPS（每秒 $10^6$ 条指令）提高到 GIPS（每秒 $10^9$ 条指令）甚至 TIPS（每秒 $10^{12}$ 条指令）水平。 1.1.2 摩尔定律但价格不变时，集成电路上可容纳的晶体管数量大约 $18 \\sim 24$ 个月翻一番，性能也将提升一倍。 1.1.3 集成电路工艺发展概述集成电路生产只要分为 IC 设计、IC 制造和 IC 封测三大环节。 1.2 计算机系统的组成1.2.1 计算机硬件系统冯·诺依曼思想： 存储程序：将解题的步骤编制成程序，然后将程序和运行程序所需要的数据以二进制的形式存到存储器中，方便执行。 程序控制：计算机中的控制器逐条取出存储器中的指令并按顺序执行，控制个功能部件进行相应的操作，完成数据的加工处理。 按照冯·诺依曼的设计思想，计算机的硬件系统包含运算器、控制器、存储器、输入设备和输出设备五大部件。 存储器：存储器的主要功能是存放程序和数据。 运算器是一种用于信息加工的部件，它对数据进行算术运算和逻辑运算。 第四章 存储系统4.1 存储器概述4.1.1 存储器分类1. 按存储介质分类 磁存储器：磁芯、磁盘、磁带存储器 半导体存储器 光存储器 2. 按存取方式分类 随机存储器（RAM） 顺序存储器（SAM） 直接存储器（DAM） 3. 按信息的可改写性分类 读写存储器 只读存储器（ROM） 4. 按信息的可保存性分类 易失性存储器 非易失性存储器 5. 按功能分类 寄存器存储器 高速缓冲存储器 主存储器 外部存储器 4.1.2 存储器技术指标1. 存储容量2. 存取速度 存取时间 存取周期 存储器带宽","categories":[],"tags":[],"author":"Lemon"},{"title":"计算机网络","slug":"计算机网络","date":"2022-03-01T01:25:27.000Z","updated":"2022-03-21T06:37:44.100Z","comments":true,"path":"posts/e255a10a.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/e255a10a.html","excerpt":"","text":"第一章 概述1.1 计算机网络在信息时代中的作用第二章 物理层2.1 物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 作用：尽可能屏蔽掉不同传输媒体和通信手段的差异。 用于物理层的协议也常称为物理层规程（procedure）。 物理层的主要任务是确定与传输媒体的接口的一些特性，有四个特征： 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压的意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 2.2 数据通信的基础知识2.2.1 数据通信系统的模型一个数据通信系统可以分为三大部分：源系统、传输系统、目的系统。 源系统一般包括两个部分： 源点：源点设备产生要传输的数据。源点也成为源站或信源。 发送器：通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器就是调制解调器。 目的系统一般也包括两个部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。 终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。终点又称为目的站或信宿。 常用术语： -","categories":[],"tags":[],"author":"Lemon"},{"title":"MySQL中的函数","slug":"MySQL中的函数","date":"2022-01-28T05:09:42.000Z","updated":"2022-01-28T05:12:46.714Z","comments":true,"path":"posts/1e2619a3.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/1e2619a3.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"各版本的MySQL的安装","slug":"各版本的MySQL的安装","date":"2022-01-27T14:23:40.000Z","updated":"2022-04-23T15:07:05.263Z","comments":true,"path":"posts/84e07c0b.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/84e07c0b.html","excerpt":"","text":"还冇写","categories":[],"tags":[]},{"title":"DCL","slug":"DCL","date":"2022-01-27T07:21:38.000Z","updated":"2022-01-27T07:35:14.947Z","comments":true,"path":"posts/2ceced73.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/2ceced73.html","excerpt":"","text":"","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"DQL","slug":"DQL","date":"2022-01-27T07:21:36.000Z","updated":"2022-01-28T05:50:35.606Z","comments":true,"path":"posts/54189da0.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/54189da0.html","excerpt":"","text":"一、概述Data Query Language，简称 DQL，数据查询语言，是用于查询数据的语言，是 SQL 的一个子集。 查询数据库数据，使用的最多的时 select 语句 有单表查询和多表查询以及嵌套查询 是数据库语言中最核心、重要的语句 使用频率最高的语句 用到的数据库代码： /* SQLyog Ultimate v10.00 Beta1 MySQL - 5.5.15 : Database - myemployees ********************************************************************* */ /*!40101 SET NAMES utf8 */; /*!40101 SET SQL_MODE=''*/; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; CREATE DATABASE /*!32312 IF NOT EXISTS*/`myemployees` /*!40100 DEFAULT CHARACTER SET gb2312 */; USE `myemployees`; /*Table structure for table `departments` */ DROP TABLE IF EXISTS `departments`; CREATE TABLE `departments` ( `department_id` int(4) NOT NULL AUTO_INCREMENT, `department_name` varchar(3) DEFAULT NULL, `manager_id` int(6) DEFAULT NULL, `location_id` int(4) DEFAULT NULL, PRIMARY KEY (`department_id`), KEY `loc_id_fk` (`location_id`), CONSTRAINT `loc_id_fk` FOREIGN KEY (`location_id`) REFERENCES `locations` (`location_id`) ) ENGINE=InnoDB AUTO_INCREMENT=271 DEFAULT CHARSET=gb2312; /*Data for the table `departments` */ insert into `departments`(`department_id`,`department_name`,`manager_id`,`location_id`) values (10,'Adm',200,1700),(20,'Mar',201,1800),(30,'Pur',114,1700),(40,'Hum',203,2400),(50,'Shi',121,1500),(60,'IT',103,1400),(70,'Pub',204,2700),(80,'Sal',145,2500),(90,'Exe',100,1700),(100,'Fin',108,1700),(110,'Acc',205,1700),(120,'Tre',NULL,1700),(130,'Cor',NULL,1700),(140,'Con',NULL,1700),(150,'Sha',NULL,1700),(160,'Ben',NULL,1700),(170,'Man',NULL,1700),(180,'Con',NULL,1700),(190,'Con',NULL,1700),(200,'Ope',NULL,1700),(210,'IT ',NULL,1700),(220,'NOC',NULL,1700),(230,'IT ',NULL,1700),(240,'Gov',NULL,1700),(250,'Ret',NULL,1700),(260,'Rec',NULL,1700),(270,'Pay',NULL,1700); /*Table structure for table `employees` */ DROP TABLE IF EXISTS `employees`; CREATE TABLE `employees` ( `employee_id` int(6) NOT NULL AUTO_INCREMENT, `first_name` varchar(20) DEFAULT NULL, `last_name` varchar(25) DEFAULT NULL, `email` varchar(25) DEFAULT NULL, `phone_number` varchar(20) DEFAULT NULL, `job_id` varchar(10) DEFAULT NULL, `salary` double(10,2) DEFAULT NULL, `commission_pct` double(4,2) DEFAULT NULL, `manager_id` int(6) DEFAULT NULL, `department_id` int(4) DEFAULT NULL, `hiredate` datetime DEFAULT NULL, PRIMARY KEY (`employee_id`), KEY `dept_id_fk` (`department_id`), KEY `job_id_fk` (`job_id`), CONSTRAINT `dept_id_fk` FOREIGN KEY (`department_id`) REFERENCES `departments` (`department_id`), CONSTRAINT `job_id_fk` FOREIGN KEY (`job_id`) REFERENCES `jobs` (`job_id`) ) ENGINE=InnoDB AUTO_INCREMENT=207 DEFAULT CHARSET=gb2312; /*Data for the table `employees` */ insert into `employees`(`employee_id`,`first_name`,`last_name`,`email`,`phone_number`,`job_id`,`salary`,`commission_pct`,`manager_id`,`department_id`,`hiredate`) values (100,'Steven','K_ing','SKING','515.123.4567','AD_PRES',24000.00,NULL,NULL,90,'1992-04-03 00:00:00'),(101,'Neena','Kochhar','NKOCHHAR','515.123.4568','AD_VP',17000.00,NULL,100,90,'1992-04-03 00:00:00'),(102,'Lex','De Haan','LDEHAAN','515.123.4569','AD_VP',17000.00,NULL,100,90,'1992-04-03 00:00:00'),(103,'Alexander','Hunold','AHUNOLD','590.423.4567','IT_PROG',9000.00,NULL,102,60,'1992-04-03 00:00:00'),(104,'Bruce','Ernst','BERNST','590.423.4568','IT_PROG',6000.00,NULL,103,60,'1992-04-03 00:00:00'),(105,'David','Austin','DAUSTIN','590.423.4569','IT_PROG',4800.00,NULL,103,60,'1998-03-03 00:00:00'),(106,'Valli','Pataballa','VPATABAL','590.423.4560','IT_PROG',4800.00,NULL,103,60,'1998-03-03 00:00:00'),(107,'Diana','Lorentz','DLORENTZ','590.423.5567','IT_PROG',4200.00,NULL,103,60,'1998-03-03 00:00:00'),(108,'Nancy','Greenberg','NGREENBE','515.124.4569','FI_MGR',12000.00,NULL,101,100,'1998-03-03 00:00:00'),(109,'Daniel','Faviet','DFAVIET','515.124.4169','FI_ACCOUNT',9000.00,NULL,108,100,'1998-03-03 00:00:00'),(110,'John','Chen','JCHEN','515.124.4269','FI_ACCOUNT',8200.00,NULL,108,100,'2000-09-09 00:00:00'),(111,'Ismael','Sciarra','ISCIARRA','515.124.4369','FI_ACCOUNT',7700.00,NULL,108,100,'2000-09-09 00:00:00'),(112,'Jose Manuel','Urman','JMURMAN','515.124.4469','FI_ACCOUNT',7800.00,NULL,108,100,'2000-09-09 00:00:00'),(113,'Luis','Popp','LPOPP','515.124.4567','FI_ACCOUNT',6900.00,NULL,108,100,'2000-09-09 00:00:00'),(114,'Den','Raphaely','DRAPHEAL','515.127.4561','PU_MAN',11000.00,NULL,100,30,'2000-09-09 00:00:00'),(115,'Alexander','Khoo','AKHOO','515.127.4562','PU_CLERK',3100.00,NULL,114,30,'2000-09-09 00:00:00'),(116,'Shelli','Baida','SBAIDA','515.127.4563','PU_CLERK',2900.00,NULL,114,30,'2000-09-09 00:00:00'),(117,'Sigal','Tobias','STOBIAS','515.127.4564','PU_CLERK',2800.00,NULL,114,30,'2000-09-09 00:00:00'),(118,'Guy','Himuro','GHIMURO','515.127.4565','PU_CLERK',2600.00,NULL,114,30,'2000-09-09 00:00:00'),(119,'Karen','Colmenares','KCOLMENA','515.127.4566','PU_CLERK',2500.00,NULL,114,30,'2000-09-09 00:00:00'),(120,'Matthew','Weiss','MWEISS','650.123.1234','ST_MAN',8000.00,NULL,100,50,'2004-02-06 00:00:00'),(121,'Adam','Fripp','AFRIPP','650.123.2234','ST_MAN',8200.00,NULL,100,50,'2004-02-06 00:00:00'),(122,'Payam','Kaufling','PKAUFLIN','650.123.3234','ST_MAN',7900.00,NULL,100,50,'2004-02-06 00:00:00'),(123,'Shanta','Vollman','SVOLLMAN','650.123.4234','ST_MAN',6500.00,NULL,100,50,'2004-02-06 00:00:00'),(124,'Kevin','Mourgos','KMOURGOS','650.123.5234','ST_MAN',5800.00,NULL,100,50,'2004-02-06 00:00:00'),(125,'Julia','Nayer','JNAYER','650.124.1214','ST_CLERK',3200.00,NULL,120,50,'2004-02-06 00:00:00'),(126,'Irene','Mikkilineni','IMIKKILI','650.124.1224','ST_CLERK',2700.00,NULL,120,50,'2004-02-06 00:00:00'),(127,'James','Landry','JLANDRY','650.124.1334','ST_CLERK',2400.00,NULL,120,50,'2004-02-06 00:00:00'),(128,'Steven','Markle','SMARKLE','650.124.1434','ST_CLERK',2200.00,NULL,120,50,'2004-02-06 00:00:00'),(129,'Laura','Bissot','LBISSOT','650.124.5234','ST_CLERK',3300.00,NULL,121,50,'2004-02-06 00:00:00'),(130,'Mozhe','Atkinson','MATKINSO','650.124.6234','ST_CLERK',2800.00,NULL,121,50,'2004-02-06 00:00:00'),(131,'James','Marlow','JAMRLOW','650.124.7234','ST_CLERK',2500.00,NULL,121,50,'2004-02-06 00:00:00'),(132,'TJ','Olson','TJOLSON','650.124.8234','ST_CLERK',2100.00,NULL,121,50,'2004-02-06 00:00:00'),(133,'Jason','Mallin','JMALLIN','650.127.1934','ST_CLERK',3300.00,NULL,122,50,'2004-02-06 00:00:00'),(134,'Michael','Rogers','MROGERS','650.127.1834','ST_CLERK',2900.00,NULL,122,50,'2002-12-23 00:00:00'),(135,'Ki','Gee','KGEE','650.127.1734','ST_CLERK',2400.00,NULL,122,50,'2002-12-23 00:00:00'),(136,'Hazel','Philtanker','HPHILTAN','650.127.1634','ST_CLERK',2200.00,NULL,122,50,'2002-12-23 00:00:00'),(137,'Renske','Ladwig','RLADWIG','650.121.1234','ST_CLERK',3600.00,NULL,123,50,'2002-12-23 00:00:00'),(138,'Stephen','Stiles','SSTILES','650.121.2034','ST_CLERK',3200.00,NULL,123,50,'2002-12-23 00:00:00'),(139,'John','Seo','JSEO','650.121.2019','ST_CLERK',2700.00,NULL,123,50,'2002-12-23 00:00:00'),(140,'Joshua','Patel','JPATEL','650.121.1834','ST_CLERK',2500.00,NULL,123,50,'2002-12-23 00:00:00'),(141,'Trenna','Rajs','TRAJS','650.121.8009','ST_CLERK',3500.00,NULL,124,50,'2002-12-23 00:00:00'),(142,'Curtis','Davies','CDAVIES','650.121.2994','ST_CLERK',3100.00,NULL,124,50,'2002-12-23 00:00:00'),(143,'Randall','Matos','RMATOS','650.121.2874','ST_CLERK',2600.00,NULL,124,50,'2002-12-23 00:00:00'),(144,'Peter','Vargas','PVARGAS','650.121.2004','ST_CLERK',2500.00,NULL,124,50,'2002-12-23 00:00:00'),(145,'John','Russell','JRUSSEL','011.44.1344.429268','SA_MAN',14000.00,0.40,100,80,'2002-12-23 00:00:00'),(146,'Karen','Partners','KPARTNER','011.44.1344.467268','SA_MAN',13500.00,0.30,100,80,'2002-12-23 00:00:00'),(147,'Alberto','Errazuriz','AERRAZUR','011.44.1344.429278','SA_MAN',12000.00,0.30,100,80,'2002-12-23 00:00:00'),(148,'Gerald','Cambrault','GCAMBRAU','011.44.1344.619268','SA_MAN',11000.00,0.30,100,80,'2002-12-23 00:00:00'),(149,'Eleni','Zlotkey','EZLOTKEY','011.44.1344.429018','SA_MAN',10500.00,0.20,100,80,'2002-12-23 00:00:00'),(150,'Peter','Tucker','PTUCKER','011.44.1344.129268','SA_REP',10000.00,0.30,145,80,'2014-03-05 00:00:00'),(151,'David','Bernstein','DBERNSTE','011.44.1344.345268','SA_REP',9500.00,0.25,145,80,'2014-03-05 00:00:00'),(152,'Peter','Hall','PHALL','011.44.1344.478968','SA_REP',9000.00,0.25,145,80,'2014-03-05 00:00:00'),(153,'Christopher','Olsen','COLSEN','011.44.1344.498718','SA_REP',8000.00,0.20,145,80,'2014-03-05 00:00:00'),(154,'Nanette','Cambrault','NCAMBRAU','011.44.1344.987668','SA_REP',7500.00,0.20,145,80,'2014-03-05 00:00:00'),(155,'Oliver','Tuvault','OTUVAULT','011.44.1344.486508','SA_REP',7000.00,0.15,145,80,'2014-03-05 00:00:00'),(156,'Janette','K_ing','JKING','011.44.1345.429268','SA_REP',10000.00,0.35,146,80,'2014-03-05 00:00:00'),(157,'Patrick','Sully','PSULLY','011.44.1345.929268','SA_REP',9500.00,0.35,146,80,'2014-03-05 00:00:00'),(158,'Allan','McEwen','AMCEWEN','011.44.1345.829268','SA_REP',9000.00,0.35,146,80,'2014-03-05 00:00:00'),(159,'Lindsey','Smith','LSMITH','011.44.1345.729268','SA_REP',8000.00,0.30,146,80,'2014-03-05 00:00:00'),(160,'Louise','Doran','LDORAN','011.44.1345.629268','SA_REP',7500.00,0.30,146,80,'2014-03-05 00:00:00'),(161,'Sarath','Sewall','SSEWALL','011.44.1345.529268','SA_REP',7000.00,0.25,146,80,'2014-03-05 00:00:00'),(162,'Clara','Vishney','CVISHNEY','011.44.1346.129268','SA_REP',10500.00,0.25,147,80,'2014-03-05 00:00:00'),(163,'Danielle','Greene','DGREENE','011.44.1346.229268','SA_REP',9500.00,0.15,147,80,'2014-03-05 00:00:00'),(164,'Mattea','Marvins','MMARVINS','011.44.1346.329268','SA_REP',7200.00,0.10,147,80,'2014-03-05 00:00:00'),(165,'David','Lee','DLEE','011.44.1346.529268','SA_REP',6800.00,0.10,147,80,'2014-03-05 00:00:00'),(166,'Sundar','Ande','SANDE','011.44.1346.629268','SA_REP',6400.00,0.10,147,80,'2014-03-05 00:00:00'),(167,'Amit','Banda','ABANDA','011.44.1346.729268','SA_REP',6200.00,0.10,147,80,'2014-03-05 00:00:00'),(168,'Lisa','Ozer','LOZER','011.44.1343.929268','SA_REP',11500.00,0.25,148,80,'2014-03-05 00:00:00'),(169,'Harrison','Bloom','HBLOOM','011.44.1343.829268','SA_REP',10000.00,0.20,148,80,'2014-03-05 00:00:00'),(170,'Tayler','Fox','TFOX','011.44.1343.729268','SA_REP',9600.00,0.20,148,80,'2014-03-05 00:00:00'),(171,'William','Smith','WSMITH','011.44.1343.629268','SA_REP',7400.00,0.15,148,80,'2014-03-05 00:00:00'),(172,'Elizabeth','Bates','EBATES','011.44.1343.529268','SA_REP',7300.00,0.15,148,80,'2014-03-05 00:00:00'),(173,'Sundita','Kumar','SKUMAR','011.44.1343.329268','SA_REP',6100.00,0.10,148,80,'2014-03-05 00:00:00'),(174,'Ellen','Abel','EABEL','011.44.1644.429267','SA_REP',11000.00,0.30,149,80,'2014-03-05 00:00:00'),(175,'Alyssa','Hutton','AHUTTON','011.44.1644.429266','SA_REP',8800.00,0.25,149,80,'2014-03-05 00:00:00'),(176,'Jonathon','Taylor','JTAYLOR','011.44.1644.429265','SA_REP',8600.00,0.20,149,80,'2014-03-05 00:00:00'),(177,'Jack','Livingston','JLIVINGS','011.44.1644.429264','SA_REP',8400.00,0.20,149,80,'2014-03-05 00:00:00'),(178,'Kimberely','Grant','KGRANT','011.44.1644.429263','SA_REP',7000.00,0.15,149,NULL,'2014-03-05 00:00:00'),(179,'Charles','Johnson','CJOHNSON','011.44.1644.429262','SA_REP',6200.00,0.10,149,80,'2014-03-05 00:00:00'),(180,'Winston','Taylor','WTAYLOR','650.507.9876','SH_CLERK',3200.00,NULL,120,50,'2014-03-05 00:00:00'),(181,'Jean','Fleaur','JFLEAUR','650.507.9877','SH_CLERK',3100.00,NULL,120,50,'2014-03-05 00:00:00'),(182,'Martha','Sullivan','MSULLIVA','650.507.9878','SH_CLERK',2500.00,NULL,120,50,'2014-03-05 00:00:00'),(183,'Girard','Geoni','GGEONI','650.507.9879','SH_CLERK',2800.00,NULL,120,50,'2014-03-05 00:00:00'),(184,'Nandita','Sarchand','NSARCHAN','650.509.1876','SH_CLERK',4200.00,NULL,121,50,'2014-03-05 00:00:00'),(185,'Alexis','Bull','ABULL','650.509.2876','SH_CLERK',4100.00,NULL,121,50,'2014-03-05 00:00:00'),(186,'Julia','Dellinger','JDELLING','650.509.3876','SH_CLERK',3400.00,NULL,121,50,'2014-03-05 00:00:00'),(187,'Anthony','Cabrio','ACABRIO','650.509.4876','SH_CLERK',3000.00,NULL,121,50,'2014-03-05 00:00:00'),(188,'Kelly','Chung','KCHUNG','650.505.1876','SH_CLERK',3800.00,NULL,122,50,'2014-03-05 00:00:00'),(189,'Jennifer','Dilly','JDILLY','650.505.2876','SH_CLERK',3600.00,NULL,122,50,'2014-03-05 00:00:00'),(190,'Timothy','Gates','TGATES','650.505.3876','SH_CLERK',2900.00,NULL,122,50,'2014-03-05 00:00:00'),(191,'Randall','Perkins','RPERKINS','650.505.4876','SH_CLERK',2500.00,NULL,122,50,'2014-03-05 00:00:00'),(192,'Sarah','Bell','SBELL','650.501.1876','SH_CLERK',4000.00,NULL,123,50,'2014-03-05 00:00:00'),(193,'Britney','Everett','BEVERETT','650.501.2876','SH_CLERK',3900.00,NULL,123,50,'2014-03-05 00:00:00'),(194,'Samuel','McCain','SMCCAIN','650.501.3876','SH_CLERK',3200.00,NULL,123,50,'2014-03-05 00:00:00'),(195,'Vance','Jones','VJONES','650.501.4876','SH_CLERK',2800.00,NULL,123,50,'2014-03-05 00:00:00'),(196,'Alana','Walsh','AWALSH','650.507.9811','SH_CLERK',3100.00,NULL,124,50,'2014-03-05 00:00:00'),(197,'Kevin','Feeney','KFEENEY','650.507.9822','SH_CLERK',3000.00,NULL,124,50,'2014-03-05 00:00:00'),(198,'Donald','OConnell','DOCONNEL','650.507.9833','SH_CLERK',2600.00,NULL,124,50,'2014-03-05 00:00:00'),(199,'Douglas','Grant','DGRANT','650.507.9844','SH_CLERK',2600.00,NULL,124,50,'2014-03-05 00:00:00'),(200,'Jennifer','Whalen','JWHALEN','515.123.4444','AD_ASST',4400.00,NULL,101,10,'2016-03-03 00:00:00'),(201,'Michael','Hartstein','MHARTSTE','515.123.5555','MK_MAN',13000.00,NULL,100,20,'2016-03-03 00:00:00'),(202,'Pat','Fay','PFAY','603.123.6666','MK_REP',6000.00,NULL,201,20,'2016-03-03 00:00:00'),(203,'Susan','Mavris','SMAVRIS','515.123.7777','HR_REP',6500.00,NULL,101,40,'2016-03-03 00:00:00'),(204,'Hermann','Baer','HBAER','515.123.8888','PR_REP',10000.00,NULL,101,70,'2016-03-03 00:00:00'),(205,'Shelley','Higgins','SHIGGINS','515.123.8080','AC_MGR',12000.00,NULL,101,110,'2016-03-03 00:00:00'),(206,'William','Gietz','WGIETZ','515.123.8181','AC_ACCOUNT',8300.00,NULL,205,110,'2016-03-03 00:00:00'); /*Table structure for table `jobs` */ DROP TABLE IF EXISTS `jobs`; CREATE TABLE `jobs` ( `job_id` varchar(10) NOT NULL, `job_title` varchar(35) DEFAULT NULL, `min_salary` int(6) DEFAULT NULL, `max_salary` int(6) DEFAULT NULL, PRIMARY KEY (`job_id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312; /*Data for the table `jobs` */ insert into `jobs`(`job_id`,`job_title`,`min_salary`,`max_salary`) values ('AC_ACCOUNT','Public Accountant',4200,9000),('AC_MGR','Accounting Manager',8200,16000),('AD_ASST','Administration Assistant',3000,6000),('AD_PRES','President',20000,40000),('AD_VP','Administration Vice President',15000,30000),('FI_ACCOUNT','Accountant',4200,9000),('FI_MGR','Finance Manager',8200,16000),('HR_REP','Human Resources Representative',4000,9000),('IT_PROG','Programmer',4000,10000),('MK_MAN','Marketing Manager',9000,15000),('MK_REP','Marketing Representative',4000,9000),('PR_REP','Public Relations Representative',4500,10500),('PU_CLERK','Purchasing Clerk',2500,5500),('PU_MAN','Purchasing Manager',8000,15000),('SA_MAN','Sales Manager',10000,20000),('SA_REP','Sales Representative',6000,12000),('SH_CLERK','Shipping Clerk',2500,5500),('ST_CLERK','Stock Clerk',2000,5000),('ST_MAN','Stock Manager',5500,8500); /*Table structure for table `locations` */ DROP TABLE IF EXISTS `locations`; CREATE TABLE `locations` ( `location_id` int(11) NOT NULL AUTO_INCREMENT, `street_address` varchar(40) DEFAULT NULL, `postal_code` varchar(12) DEFAULT NULL, `city` varchar(30) DEFAULT NULL, `state_province` varchar(25) DEFAULT NULL, `country_id` varchar(2) DEFAULT NULL, PRIMARY KEY (`location_id`) ) ENGINE=InnoDB AUTO_INCREMENT=3201 DEFAULT CHARSET=gb2312; /*Data for the table `locations` */ insert into `locations`(`location_id`,`street_address`,`postal_code`,`city`,`state_province`,`country_id`) values (1000,'1297 Via Cola di Rie','00989','Roma',NULL,'IT'),(1100,'93091 Calle della Testa','10934','Venice',NULL,'IT'),(1200,'2017 Shinjuku-ku','1689','Tokyo','Tokyo Prefecture','JP'),(1300,'9450 Kamiya-cho','6823','Hiroshima',NULL,'JP'),(1400,'2014 Jabberwocky Rd','26192','Southlake','Texas','US'),(1500,'2011 Interiors Blvd','99236','South San Francisco','California','US'),(1600,'2007 Zagora St','50090','South Brunswick','New Jersey','US'),(1700,'2004 Charade Rd','98199','Seattle','Washington','US'),(1800,'147 Spadina Ave','M5V 2L7','Toronto','Ontario','CA'),(1900,'6092 Boxwood St','YSW 9T2','Whitehorse','Yukon','CA'),(2000,'40-5-12 Laogianggen','190518','Beijing',NULL,'CN'),(2100,'1298 Vileparle (E)','490231','Bombay','Maharashtra','IN'),(2200,'12-98 Victoria Street','2901','Sydney','New South Wales','AU'),(2300,'198 Clementi North','540198','Singapore',NULL,'SG'),(2400,'8204 Arthur St',NULL,'London',NULL,'UK'),(2500,'Magdalen Centre, The Oxford Science Park','OX9 9ZB','Oxford','Oxford','UK'),(2600,'9702 Chester Road','09629850293','Stretford','Manchester','UK'),(2700,'Schwanthalerstr. 7031','80925','Munich','Bavaria','DE'),(2800,'Rua Frei Caneca 1360 ','01307-002','Sao Paulo','Sao Paulo','BR'),(2900,'20 Rue des Corps-Saints','1730','Geneva','Geneve','CH'),(3000,'Murtenstrasse 921','3095','Bern','BE','CH'),(3100,'Pieter Breughelstraat 837','3029SK','Utrecht','Utrecht','NL'),(3200,'Mariano Escobedo 9991','11932','Mexico City','Distrito Federal,','MX'); /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 二、语法SELECT [ALL|DISTINCT] {*|table.*|table.fidld1[as alias1][,table.filed2[as alias2]][,...]} FROM tableName [as table_alias] #联合查询 [WHERE ...] #筛选条件 [GROUP BY ...] #指定结果按哪几个字段分组 [HAVING] #过滤分组的记录必须满足的次要条件 [ORDER BY] #指定查询记录按一个或多个字段排序 [LIMIT {[offset,]row_count|row_countOFFSET offset}]; #指定查询的距离从哪条至哪条 [] 表示可选，{} 表示必有一个被选。 三、查询指定表的字段3.1 语法as 别名]; AS 为起别名 可给数据列取别名 可给表取别名 可把经计算或直接的结果用一个新名称来代替 AS 关键字可以省略 示例 1： SELECT `last_name`, `salary`, `email` FROM `employees`; 示例 2： SELECT `last_name` AS 姓, `salary` AS 工资, `email` AS 邮箱 FROM `employees`; 通过上面两个示例我们也看到了使用别名和不使用别名的区别。 同时我们可以通过 SELECT * FROM table_name 来查询所有字段。 3.2 关键字 DISTINCT 和 ALL作用：去重，即如果在查询结果中有重复的记录，只返回一条。 SELECT DISTINCT `department_id` FROM `employees`; 这条语句查询结果为： 如果什么也不写，则默认为 ALL，即 SELECT ALL * FROM table_name; 和 SELECT * FROM table_name 是等价的。 我们可以通过 SELECT DISTINCT COUNT(字段名) FROM table_name 来查询某个字段有多少不的值。 3.3 常量、表达式与函数 查询常量：SELECT 常量; 查询表达式：SELECT 表达式; 查询函数：SELECT 函数名(参数列表); 例如： SELECT 100; SELECT 100*99; SELECT VERSION(); 3.3.1 常用函数介绍concat() 函数功能：拼接字符（串） 语法：SELECT CONCAT(字符1，字符2，字符3...); ifnull() 函数功能：判断某字段或表达式是否为 null，如果为 null 返回指定的值，否则返回原本的值 语法：SELECT ifnull(字段,字段为null是返回的值); isnull() 函数功能：判断某字段或表达式是否为 null，如果是，则返回 1，否则返回 0. 语法：SELECT ISNULL(字段) FROM 表名; 例子例一： #案例：查询员工名和姓连接成一个字段，并显示为 姓名 SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees; 例二： SELECT IFNULL(commission_pct,0) AS 奖金率, commission_pct FROM employees; 例三： SELECT ISNULL(commission_pct),commission_pct FROM employees; 四、条件查询作用：用于过滤、筛选出表中符合筛选条件的记录。 筛选条件可由一个或多个逻辑表达式组成，结果一般为真或假。 条件运算符有：&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;. &lt;&gt; 同 != 表示不等于，&lt;=&gt; 是安全对于。 逻辑运算符有： 操作符名称 语法 描述 AND 或 &amp;&amp; 条件表达式1 AND 条件表达式2 或 条件表达式1 &amp;&amp; 条件表达式2 逻辑与，全真则真，一假则假 OR 或 ` ` NOT 或 ! NOT 条件表达式 或 !条件表达式 逻辑假，真则假，假则真 除了按条件表达式查询外，还有模糊查询，模糊查询用到的关键字有： LIKE：一般搭配通配符使用，可以匹配字符型或数值型。 BETWEEN ... AND .... IN. IS NULL|IS NOT NULL：用于判断 NULL 值。 4.1 按条件表达式或逻辑表达式查询 逻辑表达式是多个通过逻辑运算符连接起来的条件表达式。 语法： SELECT 字段1 [[AS] 别名1], 字段2 [[AS] 别名2], 字段3 [[AS] 别名3], ... 字段n [[AS] 别名n] WHERE 条件表达式1 [逻辑运算符1 条件表达式2 [逻辑运算符1 条件表达式2...]]; 4.2 按条件表达式或逻辑表达式查询的例子例一： #查询工资大于 12000 的员工信息 SELECT * FROM employees WHERE salary &gt; 12000; 例二： #查询部门编号不等于90号的员工们和部门编号 SELECT last_name,department_id FROM employees WHERE department_id &lt;&gt; 90; 例三： SELECT last_name AS 名, salary AS 工资, salary*12*IFNULL(commission_pct,0) FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000; 例四： #查询部门编号不是在90到110之间，或者工资高于15000的通过信息 SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;= 110) OR salary&gt;15000; 4.3 模糊查询 操作符名称 语法 描述 IS NULL a is NULL 若 a 为 NULL，则结果为真 IS NOT NULL a IS NOT BULL 若 a 不为 NULL，则结果为真 BETWEEN ... AND ... a BETWEEN b AND c 若 a 范围在 b 和 c 之间，则结果为真 NOT BETWEEN ... AND ... a NOT BETWEEN b AND c 若 a 范围不在 b 和 c 之间，则结果为真 LIKE a LIKE b SQL 匹配模式，若 a 匹配 b，则结果为真 IN a IN(a1,a2,a3,...) 若 a 等于 a1、a2、a3……中的某一个，则结果为真 最常用的通配符有：% 和 _，分别表示任意多个字符（包括 0 个）和单个字符。 4.4 按条件查询的例子例一： #查询员工名中包含字符 a 的员工信息 SELECT * FROM employees WHERE last_name LIKE '%a%'; 例二： #查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资 SELECT last_name, salary FROM employees WHERE last_name LIKE '__n_l%'; 例三： #查询员工名中第二个字符为 _ 的员工名 SELECT last_name FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$'; 例四： #查询员工编号在100到120之间所有的员工信息 SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120; 例五： #查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES 中的一个的员工名和工种编号 SELECT last_name, job_id FROM employees WHERE job_id IN('IT_PROG','AD_VP','AD_PRES'); 例六： #查询有奖金的员工名和奖金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NOT NULL; 4.5 几点说明 a BETWEEN b AND c 等价于 a &gt;= b &amp;&amp; a &lt;= c ，故 b 和 c 的位置不可对调。 BETWEEN ... AND ... 包含临界值。 = 和 &lt;&gt; 不可以判断 NULL 值，IS NULL 或 IS NOT NULL 可以。 IS NULL 与 &lt;=&gt;比较 普通类型的数值 null值 可读性 IS NULL × √ √ &lt;=&gt; √ √ × 五、排序查询语法： SELECT 查询列表 FROM 表 ORDER BY 查询列表 [ASC| DESC] ASC 代表升序，DESC 代表降序，不写默认为升序 ORDER BY 字句中支持单个字段、多个字段、表达式、函数、别名 ORDER BY 子句一般放在查询语句最后面，除 LIMLT 子句之外 5.1 例子例一： #查询员工信息，要求工资从高到低排序 SELECT * FROM `employees` ORDER BY `salary` DESC; 例二： #查询部门编号&gt;=90的员工信息，要求按入职时间的先后进行排序 SELECT * FROM `employees` WHERE `department_id`&gt;=90 ORDER BY hiredate ASC; 例三： #按年薪高低显示员工信息和年薪 SELECT *, salary*12*(IFNULL(commission_pct,0)+1) AS 年薪 FROM employees ORDER BY 年薪 DESC; 例四： #按姓名长度显示员工的姓名和工资 SELECT last_name AS 姓名, salary AS 工资 FROM employees ORDER BY LENGTH(last_name) DESC; 例五： #查询员工信息，要求先按工资升序排序，再按员工降序编号排序 SELECT * FROM employees ORDER BY salary ASC, employee_id DESC; 六、分组查询语法： SELECT 分组函数,分组后的字段 FROM 表 [WHERE 筛选条件] GROUP BY 分组的字段 [HAVING 分组后的筛选] [ORDER BY 排序列表 关于函数的详细介绍请参阅：MySQL中的函数 分组查询中的筛选条件可分为两类： 数据源 位置 关键字 分组前筛选 原始表 GROUP BY 子句的前面 WHERE 分组后筛选 分组后的结果集 GROUP BY 子句的后面 HAVING 分组函数做条件肯定是放在 HAING 子句中 能用分组前筛选的，优先考虑使用分组前筛选 GROUP BY 子句支持单个字段分组，多个字段分组（多个 字段之间有用逗号隔开，没有顺序要求）、表达式或函数（用得较少） 也可以添加排序（排序放在整个分组查询的最后） 6.1 例子","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"DML","slug":"DML","date":"2022-01-27T07:21:33.000Z","updated":"2022-01-27T14:27:14.339Z","comments":true,"path":"posts/b26fc0fd.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/b26fc0fd.html","excerpt":"","text":"","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"DDL","slug":"DDL","date":"2022-01-27T07:21:31.000Z","updated":"2022-01-27T10:29:08.091Z","comments":true,"path":"posts/63ad7bb4.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/63ad7bb4.html","excerpt":"","text":"一、概述Data Definition Language，简称 DDL，数据定义语言，是用于定义和管理数据如数据库、数据表这样的数据对象对象的语言，是 SQL 的一个子集。主要作用就是数据库和数据表的创建、修改和删除，用到的关键字分别为：create、alter、drop. 二、库的管理语言： #创建数据库 create database [if not exists] 库名 [DEFAULT CHARACTER SET [=] 字符集名]; #修改数据库的名字 rename database 旧表名 to 新表名; #修改库的字符集 alter database 库名 character set 字符集名; #删除数据库 drop database [if exists] 数据库名; 来个例子： #创建一个","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"结构化查询语言的介绍与基本操作","slug":"结构化查询语言的介绍与基本操作","date":"2022-01-25T11:13:19.000Z","updated":"2022-01-27T15:36:05.980Z","comments":true,"path":"posts/7fc1a07b.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/7fc1a07b.html","excerpt":"","text":"一、结构化查询语言的分类 名称 解释 命令 DDL（数据定义语言） 定义和管理数据对象，如数据库、数据表等 create、drop、alter DML（数据操作语言） 用于操作数据库对象中所包含的数据 insert、update、delete DQL（数据查询语言） 用于查询数据库数据 select DCL（数据控制语言） 用于管理数据库的语言，包括管理权限及数据更改 grant、commit、rollback 补充几个关于数据库的操作 创建数据库：create database [if not exists] 数据库名; 删除数据库：drop database [if exists] 数据库名; 查看数据库：show databases; 使用数据库：use 数据库名; 二、可视化工具介绍这里要介绍的可视化工具是 SQLyog. 特点：简洁，易用，图形化。 IntelliJ IDEA 也可以连接到数据。 三、创建数据表属于 DDL 的一种，语法： create table [if not exists] `表名` { '字段名1' 列类型 [属性][索引][注释], '字段名2' 列类型 [属性][索引][注释], ... '字段名n' 列类型 [属性][索引][注释] }[表类型][表字符集][注释]; 反引号用于区分 MySQL 关键字和普通字符。属性又称约束。 四、数据值和列类型列类型：规定数据库中该列存放的数据类型。 4.1 数值类型 类型 说明 取值范围 存储要求 tinyint 非常小的数据‘ 有符号值：$-2^7 \\sim 2^7-1$无符号值：$0 \\sim 2^8-1$ 1字节 smallint 较小的数据 有符号值：$-2^{15} \\sim 2^{15}-1$无符号值：$0 \\sim 2^{16}-1$ 2字节 mediumint 中等大小的数据 有符号值：$-2^{23} \\sim 2^{23}-1$无符号值：$0 \\sim 2^{24}-1$ 3字节 int 标准整数 有符号值：$-2^{31} \\sim 2^{31}-1$无符号值：$0 \\sim 2^{32}-1$ 4字节 bigint 较大的整数 有符号值：$-2^{63} \\sim 2^{63}-1$无符号值：$0 \\sim 2^{64}-1$ 8字节 float 单精度浮点数 $\\pm 1.1752351\\text{e}-38$ 4字节 double 双精度浮点数 $\\pm2.2250738585072014\\text{3}-308$ 8字节 decimal 字符串形式的浮点数 $\\text {decicmal}(m,d)$ 4.2 字符串类型 类型 说明 最大长度 char[(M)] 固定长度字符串，检索快但费空间，$0 \\le \\text{M} \\le 255$ M 字符 varchar[(M)] 可变长度字符串，$0 \\le \\text{M} \\le 65535$ 变长度 tinytext 微型文本串 $2^8-1$ 字节 text 文本串 $x^{16}-1$ 字节 4.3 日期和时间型数值类型 类型 说明 取值范围 DATE YYYY-MM-DD，日期格式 1000-01-01`999912-31` TIME hh:mm:ss，时间格式 -838:59:59~838:59:59 DATETIME YY-MM-DD hh:mm:ss 1000-01-01 00:00:00~9990-12-31 23:59:59 TIMESTAMP YYYYMMDDhhmmss 格式表示的时间戳 197010101000000~2037年的某个时刻 YEAR YYYY 格式的年份值 1901~2155 4.4 NULL 值 理解为“没有值”或“未知值”。 不要用 NULL 值做算术运算，结果仍为 NULL. 五、数据字段属性 Document 属性 说明 UnSigned 无符号的 声明该数据列不允许负数 ZEROFILL 0 填充的 不足位数的用 0 来填充，如 int(3,5)为 005 Auto_InCrement 自动增长的，每添加一条数据，自动在上一个记录数上加 1（默认） 通常用于设置主键，且为整数类型 可定义起始值和步长 当前表设置步长（AUTO_INCREMENT=100）：只影响当前表 SET @@auto_increment_increment=5;：影响所有使用自增的表（全局） NULL 和 NOT NULL 默认为NULL，即没有插入该列的数值 如果设置为NOT NULL，则该列必须有值 DEFAULT 默认的 用于设置默认值 例如，性别字段，默认为“男”，否则为“女”；若无指定该列的值，则默认值为“男”的值 # 目标 : 创建一个school数据库 # 创建学生表(列,字段) # 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email # 创建表之前 , 一定要先选择数据库 CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '生日', `address` VARCHAR(100) DEFAULT NULL COMMENT '地址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 # 查看数据库的定义 SHOW CREATE DATABASE school; # 查看数据表的定义 SHOW CREATE TABLE student; # 显示表结构 DESC student; # 设置严格检查模式(不能容错了)SET sql_mode='STRICT_TRANS_TABLES'; 六、数据表的类型6.1 设置数据表的类型：CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释 )ENGINE = MyISAM (or InnoDB) -- 查看mysql所支持的引擎类型 (表类型) SHOW ENGINES; MySQL 的数据表的类型 : MyISAM 、**InnoDB**、 HEAP 、 BOB 、CSV等。 常见的 MyISAM 与 InnoDB 类型： 功能 MyISAM InnoDB 事务处理 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间大小 较小 较大，约为前者的 2 倍 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度。 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表。 6.2 数据表的存储位置 MySQL 数据表以文件方式存放在磁盘中 包括表文件，数据文件，以及数据库的选项文件。 位置：如果是通过压缩包安装的，则在Mysql安装目录\\data\\下存放数据表；如果是通过安装程序安装的，则在C:/ProgramData/MySQL/MySQL Server 5.5/Data/下存放数据表。目录名对应数据库名 , 该目录下文件名对应数据表。 注意 : *. frm——表结构定义文件 . MYD——数据文件 ( data ) * . MYI——索引文件 ( index ) InnoDB 类型数据表只有一个 *.frm 文件 , 以及上一级目录的 ibdata1 文件 MyISAM 类型数据表对应三个文件 : 6.3 修改数据表 修改表名：ALTER TABLE 旧表名 RENAME AS 新表名 添加字段：ALTER TABLE 表名 ADD字段名 列属性[属性] 修改字段： ALTER TABLE 表名 MODIFY 字段名 列属性[属性] ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] 删除字段：ALTER TABLE 表名 DROP 字段名 6.4 删除数据表语法：DROP TABLE [IF EXISTS] 表名 IF EXISTS 为可选，判断是否存在该数据表 如果删除不存在的数据表会抛出错误 6.5 其他 每个库目录存在一个保存当前数据库的选项文件 db.opt 模式通配符： _ 任意单个字符 % 任意多个字符，包括零字符 单引号需要进行转义\\' CMD 命令行内的语句结束符可以为 \";\", \"\\G\", \"\\g\"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符 SQL对大小写不敏感（关键字） 清除已有语句：\\c","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"MySQL简介与安装","slug":"MySQL简介与安装","date":"2022-01-25T09:04:50.000Z","updated":"2022-02-17T07:07:25.213Z","comments":true,"path":"posts/97104bc6.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/97104bc6.html","excerpt":"","text":"一、数据库和 SQL 概述1.1 数据库的好处 持久化数据到本地。 可以实现结构化查询，方便管理。 1.2 数据库相关概念 DB（Database）：数据库，保存一组有组织的数据的容器。 DBMS（Database Management System）：数据库管理系统，即数据库软件（产品），用于管理 DB 中的数据。 SQL（Structure Query Language）：结构化查询语言，用于和 DBMS 通信。 1.3 数据库存储数据的特点 将数据放到表中，再将表放到库中。 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 表具有唯一性，这些特性定义了数据在表中如何存储，类似于 Java 中的“类”。 表由列组成，我们也称之为字段。所以表都是由一个或多个列组成，每一列类似于 Java 中的属性。 表中的数据是按行存储的，每一行相当于 Java 的对象。 1.4 常见的 DBMS MySQL Oracle DB2 SQLServer 二、MySQL 的介绍，安装和使用 2.1 MySQL 数据库产品的介绍 MySQL 数据库隶属于 MySQL AB公司，总部位于瑞典，后被 Oracle 收购。 优点： 成本低：开放源代码，一般可以免费试用。 性能高：执行很快。 简单：很容易安装和使用 2.2 MySQL 数据库的安装（以 5.5 为例） DBMD 分为两类： 基于共享文件系统的 DBMS：Access. 基于客户机——服务器的 DBMS：MySQL、Oracle、SQLServer. MySQL 国内镜像 其他版本的MySQL的安装方法 2.2.1 安装 2.2.2 配置安装完毕后，会看到如下界面： 如果不小心关闭了这个界面，可进入 MySQL 安装目录下的 bin 目录，找到 MySQLInstanceConfig.exe，双击打开。 开始配置 至此，配置完毕。 2.3 配置文件介绍 可直接修改配置文件来设置相关的功能。 三、MySQL 的使用3.1 MySQL 服务的启动和停止3.1.1 方式一 右击可启动、停止和查看属性 在属性界面可以把启动类型改成手动 3.1.2 方式二tg 通过 net start mysql服务名 启动 MySQL 服务： 通过 net stop mysql服务名 停止 MySQL 服务： 3.2 MySQL 的登陆和退出3.2.1 方式一：通过 MySQL 自带客户端登陆（不建议使用） 这种方式貌似只能登陆到 root 用户，故不建议使用。 exit 或 ctrl + c 退出 3.2.2 方式二：通过命令行登陆使用 mysql -h 主机名 端口号 -u 用户名 -p[密码] 登陆。 如果要登陆到本机端口号为 3306 的 MySQL 数据库可简写为：mysql -u 用户名 -p密码. 退出：exit 或 ctrl + c 四、MySQL 常用命令4.1 查看当前所有的数据库——SHOW DATABASES; 4.2 打开某个库——USE 库名; 4.3 查看当前库中所有表——SHOW TABLES; 4.4 查看指定库的所有表——SHOW TABLES FROM 库名; 4.5 创建数据库——CREATE DATABASE [if not exists] 数据库名; 4.6 删除数据库——drop database [if exists] 数据库名; 4.7 创建表语法： create table 表名( 列名 列类型, 列名 列类型， ... ); 4.8 查看表结构——DESC 表名; 4.9 查看当前所在库——SELECT DATABASE(); 4.10 查看 MySQL 版本4.10.1 方式一：登陆到 MySQL 服务端select version(); 4.10.2 方式二：没有登陆到 MySQL 服务器 mysql --version 4.11 修改指定用户密码语法： update user set password=password('新密码')where user='用户名'; 这条命令实际上是修改 mysql 库中的 user 表的 password 字段。 五、MySQL 的语法规范 不区分大小写，但建议关键字大写，表名、列明小写。 每条最好用分号结尾。 每条命令根据需要，可以进行缩进或换行。 注释： 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：/* 注释文字 */","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"}],"author":"Lemon"},{"title":"数学公式","slug":"数学公式","date":"2022-01-24T07:46:52.000Z","updated":"2022-04-07T15:22:22.783Z","comments":true,"path":"posts/3d3518c5.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/3d3518c5.html","excerpt":"","text":"希腊字母 效果（大写/小写） Tex MathJax 变体 变体语法 $\\text{A}\\alpha$ \\alpha\\alpha \\text{A}\\alpha 或 {\\rm A} \\alpha $\\text{B}\\beta$ \\Beta\\beta \\text{B}\\beta 或 {\\rm B}\\beta $\\Gamma\\gamma$ \\Gamma\\gamma \\Gamma\\gamma $\\Delta\\delta$ \\Delta\\delta \\Delta\\delta $\\text{E}\\epsilon$ \\Epsilon\\epsilon \\text{E}\\epsilon 或 {\\rm E}\\epsilon $\\varepsilon$ \\varepsilon $\\text{Z}\\zeta$ \\Zeta\\zeta \\text{Z}\\zeta 或 {\\rm E}\\epsilon $\\text{E}\\eta$ \\Eta\\eta \\text{E}\\eta 或 {\\rm E}\\eta $\\Theta\\theta$ \\Theta\\theta \\Theta\\theta $\\vartheta$ \\vartheta $\\text{I}\\iota$ \\Iota\\iota \\text{I}\\iota 或 {\\rm I}\\iota $\\text{K}\\kappa$ \\Kappa\\kappa \\text{K}\\kappa 或 {\\rm K}\\kappa $\\Lambda\\lambda$ \\Lambda\\lambda \\Lambda\\lambda $\\text{M}\\mu$ \\Mu\\mu \\text{M}\\mu 或 {\\rm M}\\mu $\\text{N}\\nu$ \\Nu\\nu \\text{N}\\nu 或 {\\rm N}\\nu $\\Xi\\xi$ \\Xi\\xi \\Xi\\xi $\\text{O}\\omicron$ \\Omicron\\omicron \\text{O}\\omicro 或 {\\rm O}\\omicro $\\Pi\\pi$ \\Pi\\pi \\Pi\\pi $\\varpi$ \\varpi $\\text{P}\\rho$ \\Rho\\rho \\text{P}\\rho 或 {\\rm P}\\rho $\\varrho$ \\varrho $\\Sigma\\sigma$ \\Sigma\\sigma \\Sigma\\sigma $\\varsigma$ \\varsigma $\\text{T}\\tau$ \\Tau\\tau \\text{T}\\tau 或 {\\rm T}\\tau $\\Upsilon\\upsilon$ \\Upsilon\\upsilon \\Upsilon\\upsilon $\\Phi\\phi$ \\Phi\\phi \\Phi\\phi $\\varphi$ \\varphi $\\text{X}\\chi$ \\Chi\\chi \\text{X}\\chi 或 {\\rm X}\\chi $\\Psi\\psi$ \\Psi\\psi \\Psi\\psi $\\Omega\\omega$ \\Omega\\omega \\Omega\\omega 注：字母 $\\text{ABEIKMNOPTX}$ 在 MathJax 中只能通 \\text{字母} 或 {\\rm 字母} 的形式来表示，但在 Tex 中依然可以用类似于 \\Alpha 的形式来表示。希腊字母的变体在数学和物理中也经常被使用。 上下标$$a^2,a_1$$ $$a^2,a_1$$ $$x^{y + z},p_{ij}$$ $$x^{y + z},p_{ij}$$ 如果上下标是由一个表达式或多个字母，则应当将它们放在 {} 中，类似于 a^{b+c}. 分式与根式$$\\frac{1}{2},\\frac 1 2$$ $$\\frac{1}{2},\\frac 1 2$$ $$\\frac 1 {x+y}$$ $$\\frac 1 {x+y}$$ $$\\frac {\\frac 1 x + 1}{y + 1}, \\frac {\\dfrac 1 x + 1}{y + 1},\\frac {\\cfrac 1 x + 1}{y + 1}$$ $$\\frac {\\frac 1 x + 1}{y + 1}, \\frac {\\dfrac 1 x + 1}{y + 1},\\frac {\\cfrac 1 x + 1}{y + 1}$$ 同样的，分子或分母是由一个表达式或多个字母时，应当将它们放在 {} 中，frac、dfrav、cfrac 的区别是，dfrac 的上下间距较大，cfrac 离地更高。当然，不同的编辑器的渲染效果会有所不同，视具体情况选择。 \\sqrt 2,\\sqrt{x+y},\\sqrt[3]x $$\\sqrt 2,\\sqrt{x+y},\\sqrt[3]x$$ 一些运算符$$+-=$$ $$+-=$$ $$\\times,\\cdot,\\div$$ $$\\times,\\cdot,\\div$$ $$\\pm,\\mp$$ $$\\pm,\\mp$$ $$\\gt,\\lt,\\ge,\\le,\\gg,\\ll,\\ne,\\not=,\\approx,\\equiv$$ $$\\gt,\\lt,\\ge,\\le,\\gg,\\ll,\\ne,\\not=,\\approx,\\equiv$$ $$\\cap,\\cup,\\in,\\notin,\\subseteq,\\subseteqq,\\subsetneq,\\subsetneqq,\\varnothing$$ $$\\cap,\\cup,\\in,\\notin,\\subseteq,\\subseteqq,\\subsetneq,\\subsetneqq,\\varnothing$$ $$\\forall,\\exists,\\nexists$$ $$\\forall,\\exists,\\nexists$$ $$\\because,\\therefore$$ $$\\because,\\therefore$$ 大型运算符$$\\sum,\\prod$$ $$\\sum,\\prod$$ $$\\sum_{i=1}^n a_i,\\prod_i^n b_i$$ $$\\sum_{i=1}^n a_i,\\prod_{i=1}^n b_i$$ $$\\frac{\\sum_{i=1}^n a_i}{\\prod_{i=1}^n b_i}$$ $$\\frac{\\sum_{i=1}^n a_i}{\\prod_{i=1}^n b_i}$$ $$\\frac{\\sum\\limits_{i=1}^n a_i}{\\prod\\limits_{i=1}^n b_i}$$ $$\\frac{\\sum\\limits_{i=1}^n a_i}{\\prod\\limits_{i=1}^n b_i}$$ 用 _ 和 ^ 来分别表示运算的上下限，\\limits 是强制让上下限严格在运算符的上面和下面 积分符号$$\\int,\\iint,\\iiint,\\oint$$ $$\\int,\\iint,\\iiint,\\oint$$ $$\\int_{a}^{b} f(x) \\mathrm{d} x,\\iint \\limits_D f(x,y) \\mathrm{d} xy, \\iiint \\limits _{\\Omega} f(x,y,z) \\mathrm{d}xyz$$ $$\\int_{a}^{b} f(x) \\mathrm{d} x,\\iint \\limits_D f(x,y) \\mathrm{d} xy, \\iiint \\limits _{\\Omega} f(x,y,z) \\mathrm{d}xyz$$ 也是使用 _ 和 ^ 来分别表示运算的上下限，\\limits 强制让上下限严格在运算符的上面和下面。在 MathJax 中好像不支持 \\oiint 和 \\oiiint，但在 Tex 中是支持的。在 Tex 中，只有一个符号表示变量时我们才使用斜体，其他的我们都要修正为正体，对于 $\\sin、\\cos、\\log、\\ln$ 这些，直接通过 \\sin 这种形式来表示，对于没有内置的符号，则可以通过 \\mathrm{符号} 或来修饰。微分符号 ${\\rm d}$ 也应该为正体。 一些符号$$\\mathbb R,\\mathbb Q,\\mathbb N,\\mathbb Z_+$$ $$\\mathbb R,\\mathbb Q,\\mathbb N,\\mathbb Z_+$$ 在 Tex 可直接用 \\R 来达到上面的效果，而在 MathJax 中貌似只能通过 \\mathbb R 来达到上面的效果。当需要表示集合时，请使用上面的符号 \\cdots,\\vdots,\\ddots $$\\cdots,\\vdots,\\ddots$$ \\infty,\\partial,∂,\\nabla,\\propto，^{\\circ} $$\\infty,\\partial,∂,\\nabla,\\propto, ^{\\circ}$$ Tex 中支持 \\degree 来表示度，在 MathJax 中好像不支持，这里使用的是 ^{\\circ} 来代替 \\sin x ,\\sec x, \\cosh x,\\log_2 x, \\ln x, \\lg x,\\max x $$\\sin x ,\\sec x, \\cosh x,\\log_2 x, \\ln x, \\lg x,\\max x$$ 标志符号\\vec x,\\overrightarrow {AB},\\bar x,\\overline{AB} $$\\vec x,\\overrightarrow {AB},\\bar x,\\overline{AB}$$ 箭头\\leftarrow,\\rightarrow,\\leftrightarrow,\\Leftarrow,\\Rightarrow,\\Leftrightarrow,\\longleftarrow,\\longrightarrow,\\longleftrightarrow,\\Longleftarrow,\\Longrightarrow,\\Longleftrightarrow $$\\leftarrow,\\rightarrow,\\leftrightarrow,\\Leftarrow,\\Rightarrow,\\Leftrightarrow,\\longleftarrow,\\longrightarrow,\\longleftrightarrow,\\Longleftarrow,\\Longrightarrow,\\Longleftrightarrow$$ 括号与定界符()[]\\{ \\} \\lbrace $$()[]{ }\\lbrace\\rbrace$$ \\lceil,\\rceil,\\lfloor,\\rfloor,|| $$\\lceil,\\rceil,\\lfloor,\\rfloor,||$$ \\left(0,\\frac 1 a\\right] $$\\left(0,\\frac 1 a\\right]$$ 使用 \\left 和 \\right 来修饰括号会使其具有自适应大小的特性 \\left.\\frac {∂f}{∂x}\\right|_{x=0} $$\\left.\\frac {∂f}{∂x}\\right|_{x=0}$$ 通过 \\left. 和 \\right| 使 | 具有自适应大小的特性 多行公式\\begin{aligned} a &amp; =b+c+d \\newline &amp; =e+f \\end{aligned} $$\\begin{aligned}a &amp; =b+c+d \\newline &amp; =e+f\\end{aligned}$$ $$ \\begin{align} a&amp;=b+c+d \\newline &amp;=e+f \\end{align} $$ $$\\begin{align}a&amp;=b+c+d \\newline&amp;=e+f\\end{align}$$ 上面的两种方式是一样的。注意：在 MathJax 中，换行请用 \\newline，在 Tex 中是支持 \\\\ 换行的. 大括号f(x)= \\begin{cases} \\sin x, &amp; -π\\le x \\le π\\newline 0,&amp; \\text{其他} \\end{cases} $$f(x)=\\begin{cases}\\sin x, &amp; -π\\le x \\le π\\newline0,&amp; \\text{其他}\\end{cases}$$ $$ f(x)= \\left\\lbrace\\begin{array}{ll} \\sin x, &amp; -\\pi\\le x \\le \\pi\\newline 0,&amp; \\text{其他} \\end{array}\\right. $$ $$f(x)= \\left\\lbrace\\begin{array}{ll}\\sin x, &amp; -\\pi\\le x \\le \\pi\\newline0,&amp; \\text{其他}\\end{array}\\right.$$ 在 MathJax 中，大括号 请使用 \\lbrace 表示。 \\begin{matrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{matrix} $$\\begin{matrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{matrix}$$ \\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{array} $$\\begin{array}{cccc}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{array}$$ \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{bmatrix} $$\\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{bmatrix}$$ $$ \\left[\\begin{array}{llll} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{array}\\right] $$ $$\\left[\\begin{array}{llll}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{array}\\right]$$ \\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{pmatrix} $$\\begin{pmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{pmatrix}$$ \\left(\\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{array}\\right) $$\\left(\\begin{array}{cccc}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{array}\\right)$$ \\begin{vmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{vmatrix} $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{vmatrix}$$ \\left|\\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newline a_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newline a_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline a_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n} \\end{array}\\right| $$\\left|\\begin{array}{cccc}a_{11} &amp; a_{12} &amp; a_{13} &amp; \\cdots &amp; a_{1n} \\newlinea_{21} &amp; a_{22} &amp; a_{23} &amp; \\cdots &amp; a_{2n} \\newlinea_{31} &amp; a_{32} &amp; a_{33} &amp; \\cdots &amp; a_{3n} \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinea_{n1} &amp; a_{n2} &amp; a_{n3} &amp; \\cdots &amp; a_{(n-1)n}\\end{array}\\right|$$ 另外，用 \\bf A 来表示矩阵，\\bf B^{\\rm T} 表示矩阵的转置 $$\\bf A,\\bf B^{\\rm T}$$ 几个例子正态分布$$f(x) = \\frac{1} {\\sqrt {2\\pi} \\sigma}{\\mathrm e}^{-\\frac{(x-\\mu)^2}{2\\sigma ^ 2}}$$ $$f(x) = \\frac{1} {\\sqrt {2\\pi} \\sigma}{\\mathrm e}^{-\\frac{(x-\\mu)^2}{2\\sigma ^ 2}}$$ $$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left[-\\frac{(x-\\mu)^2}{2\\sigma ^ 2}\\right]$$ $$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left[-\\frac{(x-\\mu)^2}{2\\sigma ^ 2}\\right]$$ 麦克斯韦方程组$$ \\begin{aligned} \\oint _l \\boldsymbol{H} \\cdot \\mathrm{d} \\boldsymbol{l} &amp; = \\iint_S \\boldsymbol{J} \\cdot \\mathrm{d} \\boldsymbol{S} + \\iint_S \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot {\\mathrm d}\\boldsymbol{S} \\newline \\oint_l \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l} &amp; = -\\iint_s \\frac{\\partial \\boldsymbol{B}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S}\\newline \\oint_S \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}&amp; = 0 \\newline \\oint_S \\boldsymbol{D} \\cdot \\mathrm{d} \\boldsymbol{S} &amp; = \\iiint_V \\rho \\mathrm{d} V \\end{aligned} $$ $$\\begin{aligned}\\oint _l \\boldsymbol{H} \\cdot \\mathrm{d} \\boldsymbol{l} &amp; = \\iint_S \\boldsymbol{J} \\cdot \\mathrm{d} \\boldsymbol{S} + \\iint_S \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot {\\mathrm d}\\boldsymbol{S} \\newline\\oint_l \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l} &amp; = -\\iint_s \\frac{\\partial \\boldsymbol{B}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S}\\newline\\oint_S \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}&amp; = 0 \\newline\\oint_S \\boldsymbol{D} \\cdot \\mathrm{d} \\boldsymbol{S} &amp; = \\iiint_V \\rho \\mathrm{d} V\\end{aligned}$$ \\begin{aligned} \\nabla \\times \\boldsymbol{H} &amp; = \\boldsymbol{J} + \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\newline \\nabla \\times \\boldsymbol{E} &amp; = - \\frac{\\partial \\boldsymbol{B}}{\\partial t} \\newline \\nabla \\cdot \\boldsymbol{B} &amp; = 0 \\newline \\nabla \\cdot \\boldsymbol{D} &amp; = \\rho \\end{aligned} $$\\begin{aligned}\\nabla \\times \\boldsymbol{H} &amp; = \\boldsymbol{J} + \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\newline\\nabla \\times \\boldsymbol{E} &amp; = - \\frac{\\partial \\boldsymbol{B}}{\\partial t} \\newline\\nabla \\cdot \\boldsymbol{B} &amp; = 0 \\newline\\nabla \\cdot \\boldsymbol{D} &amp; = \\rho\\end{aligned}$$ 范德蒙德行列式$$ \\begin{vmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\newline x_{1} &amp; x_{2} &amp; x_{3} &amp; \\cdots &amp; x_{n} \\newline x_{1}^2 &amp; x_{2}^2 &amp; x_{3}^2 &amp; \\cdots &amp; x_{n}^2 \\newline x_{1}^3 &amp; x_{2}^3 &amp; x_{3}^3 &amp; \\cdots &amp; x_{n}^3 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline x_{1}^{n-1} &amp; x_2^{n-1} &amp; x_{3}^{n-1} &amp; \\cdots &amp; x_n^{n-1} \\end{vmatrix} = \\prod_{1 \\le j \\le i \\le n}(x_i - x_j) $$ $$\\begin{vmatrix}1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\newlinex_{1} &amp; x_{2} &amp; x_{3} &amp; \\cdots &amp; x_{n} \\newlinex_{1}^2 &amp; x_{2}^2 &amp; x_{3}^2 &amp; \\cdots &amp; x_{n}^2 \\newlinex_{1}^3 &amp; x_{2}^3 &amp; x_{3}^3 &amp; \\cdots &amp; x_{n}^3 \\newline\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newlinex_{1}^{n-1} &amp; x_2^{n-1} &amp; x_{3}^{n-1} &amp; \\cdots &amp; x_n^{n-1}\\end{vmatrix} = \\prod_{1 \\le j \\le i \\le n}(x_i - x_j)$$ 欧拉恒等式\\mathrm{e}^{\\mathrm{i} x} = \\cos x + \\mathrm{i} \\sin x $$\\text{e}^{\\text{i} x} = \\cos x + \\text{i} \\sin x$$ 巴塞尔问题1 + \\frac{1}{2^2} + \\frac{1}{3^2} + \\cdots = \\sum_{i=1}^{\\infty} \\frac{1}{i^2} =\\frac{\\pi^{2}}{6} $$1 + \\frac{1}{2^2} + \\frac{1}{3^2} + \\cdots = \\sum_{i=1}^{\\infty} \\frac{1}{i^2} =\\frac{\\pi^{2}}{6}$$ 斐波那契数列$$ F(n)= \\left\\lbrace\\begin{array}{ll} 1, &amp;n \\le 2\\newline F(n-1) + F(n-2),&amp; n \\ge 3 \\end{array}\\right. $$ $$F(n)= \\left\\lbrace\\begin{array}{ll}1, &amp;n \\le 2\\newlineF(n-1) + F(n-2),&amp; n \\ge 3\\end{array}\\right.$$ 牛顿莱布尼茨公式$\\int _a^b f(x)\\mathrm{d}x = F(b) - F(a)$$ $$\\int _a^b f(x)\\mathrm{d}x = F(b) - F(a)$$","categories":[],"tags":[],"author":"Lemon"},{"title":"异或运算的性质与拓展","slug":"异或运算的性质与拓展","date":"2022-01-09T13:56:30.000Z","updated":"2022-01-19T06:14:52.241Z","comments":true,"path":"posts/d7710b2d.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/d7710b2d.html","excerpt":"","text":"0x01 简介异或运算是位运算的一种，在计算机语言中一般用 ^ 符号来表示，它是一个二元运算。对于两个二进制位为来说，运算的结果为： a b a ^ b 0 0 0 0 1 1 1 0 1 1 1 0 可以看出，当两个参与运算的数相等是结果为 0，不等是结果为 1。 异或运算还可以看成无进位加法。 对于两个数来说，他们异或的结果是它们的对应二进制位相应做异或运算得到的结果，如：10110 和 00111 异或得到的结果为 10001 0x02 性质 $0 ^{\\wedge} N = N$，$N ^{\\wedge} N = 0$ 交换律： $a ^{\\wedge} b = b ^{\\wedge} a$ 结合律： $(a ^{\\wedge} b) ^{\\wedge} c = a ^{\\wedge} (b ^{\\wedge} c)$ $a_{1} ^{\\wedge} a_{2} ^{\\wedge} a_{3} ^{\\wedge} \\cdots ^{\\wedge} a_{n}$ 的结果与 $a_{1}, a_{2}, a_{3}, \\cdots ,a_{n}$ 的顺序无关 0x03 异或运算在编程中的运用1、利用异或运算实现 swap() 方法一般的 swap() 方法的写法如下 public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 借助一个额外变量可做到交换两数 由于 Java 语言的基础类型没有 C/C++ 中的指针传递或引用传递，只有值传递，我们不能写成 swap(int a, int b) 这样的方法。 再来看看版本的： public static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } 假设 arr[i] = 甲; arr[j] = 3 arr[i] = arr[i] ^ arr[j] = 甲 ^ 乙; arr[j] = 乙; arr[j] = arr[i] ^ arr[j] = 甲 ^ 乙 ^ 乙 = 甲; arr[i] = 甲 ^ 乙; arr[i] = arr[i] ^ arr[j] = 甲 ^ 乙 ^ 甲 = 乙; arr[j] = 甲 可以看到通过三次异或元素我们成功将 arr[i] 和 arr[j] 的数据交换了过来。 注意：使用这种方法来实现两数交换，被交换的两数在内存上必须是两块独立的空间，否则会使两个数的值变成 0. 2、一个与异或有关的题题目描述：一个数组中有一种数出现了奇数次，其他数出现了偶数次，请你求出这个数 这题的解法很简单，我们只需把数组中所以的数都异或一遍，最后得到的结果即为要求的数。 由于异或运算具有结合律和交换律，所以我们可以先把所以出现偶数个的数两两异或，会到的若干个 0，在将出现奇数个数的那个数零零异或，会得到若干个 0，还会剩下一个这个数，将所以的 0 和这个数异或就可以得到这个数了。 代码如下： public static void printOddTimesNum(int[] arr) { int res = 0; for (int a : arr) { res ^= a; } System.out.println(res); } 3、进阶题题目描述：一个数组中有两种数出现了奇数次，其他数出现了偶数次，请你求出这两个数 这题的解法较为难理解，我们假设这两个数为 a 和 b，将数组中所有的数异或得到的结果为 a ^ b，由题意知， $a \\not= b $，故 $a ^{\\wedge} b \\not = 0$，不妨记 $eor = a ^{\\wedge} b$，则 $eor \\not = 0$，接下来要想办法分离 a 和 b。 由于 $a ^ b \\not = 0$，所以 a 和 b 的二进制为至少有一个不相同，这样一来 eor 至少有一个二进制位为 1。假定这个二进制为为第八位，那么 a 和 b 的第八位比如不同。也就是说，可以通过 eor 的第八位区分出 a 和 b。同时，我们也可以通过第八位来划分数组，即第八位上为 0 的为一部分，第八位上为 1 的为另一部分，a 和 b 必不可能在同一部分里。其他的数在自己所在的那部分必然会出现偶数次。我们可以拿到 eor 最右侧的 1，然后通过这个是数来划分数组。 下面给出一段代码： int rightOne = eor &amp; (~eor + 1); 这段代码就可以求出 eor 最右侧的1，可能有点难理解，我们直接看一个例子： 然后就可以求出这两个数了，完整代码如下： public static void printOddTimesNum(int[] arr) { int eor = 0; int rightOne = 0; for (int a : arr) { eor ^= a; } rightOne = eor &amp; (~eor + 1); int a = 0; int b = 0; for (int c : arr) { if ((c &amp; rightOne) == 0) { a ^= c; } } b = a ^ eor; System.out.println(a + \" \" + b); }","categories":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"位运算","permalink":"https://lemonsama123.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"异或运算","slug":"异或运算","permalink":"https://lemonsama123.gitee.io/tags/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/"}],"author":"Lemon"},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2021-12-16T14:55:34.000Z","updated":"2021-12-17T06:53:13.190Z","comments":true,"path":"posts/bbcf5ff7.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/bbcf5ff7.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"GCD","slug":"GCD","date":"2021-12-16T14:48:19.000Z","updated":"2022-01-19T06:17:43.534Z","comments":true,"path":"posts/2071db18.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/2071db18.html","excerpt":"","text":"简介GCD，即最大公约数，是指多个整数共有约数中最大的一个，常见的求解方法有质因数分解法、短除法、辗转相除法和更相减损法 辗转相除法引例我们尝试使用辗转相除法求 319 和 377 的最大公倍数： 通过上述求解过程，我们可以得到递归方程：$$\\text{GCD}(a, b) = \\text{GCD}(b, a \\mod b)$$结束条件为：$b = 0$ 递归实现public static int GCD(int a, int b) { if (b == 0) { return a; } else { return GCD(b, a % b); } } 迭代实现public static int GCD(int a, int b) { while (b != 0) { int t = a; a = b; b = t % b; } return a; } Stein算法Stein算法是一种计算两个数最大公约数的算法，是针对欧几里德算法在对大整数进行运算时，需要试商导致增加运算时间的缺陷而提出的改进算法。 算法描述 设置 $a_{n}=|a|$、$b_{n}=|b|$、$c_{n} = 1$ 和 $ n = 1$ 如果 $a_{n} = b_{n}$，那么 $a_{n}$（或 $b_{n}$）* $c_{n}$ 是最大公约数，算法结束 如果 $a_{n} = 0$，$b_{n}$ 是最大公约数，算法结束 如果 $b_{n} = 0$，$a_n$ 是最大公约数，算法结束 如果 $a_{n}$ 和 $b_{n}$ 都是偶数，则 $a_{n+1} = \\frac{a_n}{2}$，$b_{n+1} = \\frac{b_n}{2}$，$c_{n+1} = c_{n}*2$ 如果 $a_{n}$ 是偶数，$b_{n}$ 不是偶数，则 $a_{n+1} = \\frac{a_{n}}{2}$，$b_{n+1} = b_{n}$，$c_{n+1}= c_{n}$ 如果 $b_{n}$ 是偶数，$a_{n}$ 不是偶数，则$b_{n+1}=\\frac{b_{n}}{2}$，$a_{n+1} = a_{n}$，$c_{n+1} = c_{n}$ 如果 $a_{n}$ 和 $b_{n}$ 都不是偶数，则 $a_{n+1} = \\frac{|An-Bn|}{2}$，$b_{n+1} = \\min(a_{n},b_{n})$，$c_{n+1} = c_{n}$ n=n+1，转2 Java 实现。。。。。。","categories":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"Lemon"},{"title":"快速幂","slug":"快速幂","date":"2021-12-16T14:41:52.000Z","updated":"2022-03-21T06:46:45.462Z","comments":true,"path":"posts/20c47d09.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/20c47d09.html","excerpt":"","text":"简介快速幂（Fast Power）算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。可以以 $O(\\log n)$ 的时间复杂度计算乘方。 引例来看一个简单的问题：求 3 的 10 次幂，怎样算比较快？ 方法1：最简单的想法：$3 \\times 3 = 9, 9 \\times 3 = 27, \\cdots , 19683 \\times 3 = 359049$，共需做 9 次乘法 方法2：先算 3 的 5 次幂，$3 \\times 3 \\times 3 \\times 3 \\times 3 = 243$，再计算 $3^{5}$ 的平方，共需做 6 次乘法 方法3：先计算 $3^{2}$，再计算 $3^{5} = 3^{2} \\times 3^{2} \\times 3$，再计算其平方，共需做 5 次乘法 递归快速幂快速幂，无非是二分的思想。根据刚刚的例子可以得到递归方程：$$a^{n}=\\left\\lbrace\\begin{array}{ll}a^{n-1} \\cdot a, &amp; n \\text { 为奇数} \\newlinea^{\\frac{n}{2}} \\cdot a^{\\frac{n}{2}}, &amp; n \\text { 为不为 0 的偶数}\\newline1, &amp; n=0\\end{array}\\right.$$根据递归方程可以写成代码： public static int fastPower(int a, int n) { if (n == 0) { return 1; } else if (n % 2 != 0) { return fastPower(a, n - 1) * a; } else { int res = fastPower(a, n &gt;&gt; 1); return res * res; } } 注意：变量 res 是必要的，因为如果不把 $a^{\\frac{n}{2}}$ 记录下来，直接写成 fastPower(a, n &gt;&gt; 2) * fastPower(a, n &gt;&gt; 2)，会计算两次 $a^{\\frac{n}{2}}$，算法就退化为 $O(n)$ 了 在实际问题中，可能要求求出幂后对一个素数取模，这时我们没有必要真的先求出结果再取模，可根据同余定理，步步取模 public static int fastPowerMod(int a, int n, int mod) { if (n == 0) { return 1; } else if (n % 2 != 0) { return fastPower(a, n - 1) * a % mod; } else { int res = fastPower(a, n &gt;&gt; 1) % mod; return res * res % mod; } } 众所周知，递归简洁，但会产生额外的空间开销。我们可以把递归改成迭代（循环），来避免对系统栈的大量占用，即非递归快速幂 非递归快速幂我们可以直接由递归快速幂得到非递归快速幂： public static int fastPower(int a, int n) { int res = 1; while (n != 0) { if (n % 2 != 0) { res *= a; } a *= a; n &gt;&gt;= 1; } return res; } 我们换一个角度来看非递归快速幂。还是 3 的 10 次幂，但这次，我们把 10 写成二进制的形式，也就是 $(1010)_{2}$。 现在我们要计算 $3^{(1010)}$，可以这样做 $3^{(1010)} = 3^{(1000)} \\cdot 3^{(10)}$，实际上，对于任意的整数次幂，我们都可以拆分成若干个 $3^{(100\\cdots)}$ 的形式，这正好对应 $3^{1}$、$3^{2}$、$3^{4} \\cdots$，我们只需把底数不断平方就可以得到结果。 先来看看代码，再仔细推敲推敲： public static int fastPower1(int a, int n) { int res = 1; while (n != 0) { if ((n &amp; 1) != 0) { res *= a; } a *= a; n &gt;&gt;= 1; } return res; } 对于指数的二进制数，如果某一位为 0，则这一位的对应的数弃去，如果为 1，则让 res 乘上对应的 a 的次幂 矩阵快速幂上述的都是整数的快速幂。实际上，只要一个数据类型支持乘法且满足结合律，都可使用快速幂，矩阵快速幂就是其典型应用，而斐波那契数列是矩阵快速幂的一个典型应用 斐波那契数列$$F_{n}=\\left\\lbrace\\begin{array}{ll}1 &amp; (n \\leq 2)\\newlineF_{n-1}+F_{n-2} &amp; (n \\geq 3)\\end{array}\\right.$$ 题目描述：求出 $F_{n} \\mod 10^9 + 7$ 的值 设矩阵 $A=\\left[\\begin{array}{ll}0 &amp; 1 \\newline1 &amp; 1\\end{array}\\right]$，我们有：$$A\\left[\\begin{array}{c}F_{n} \\newlineF_{n+1}\\end{array}\\right]=\\left[\\begin{array}{c}F_{n+1} \\newlineF_{n}+F_{n+1}\\end{array}\\right]=\\left[\\begin{array}{l}F_{n+1} \\newlineF_{n+2}\\end{array}\\right]$$于是：$$\\begin{aligned}\\left[\\begin{array}{c}F_{n} \\newlineF_{n+1}\\end{array}\\right] &amp;=A\\left[\\begin{array}{c}F_{n-1} \\newlineF_{n}\\end{array}\\right] \\newline&amp;=A^{2}\\left[\\begin{array}{c}F_{n-2} \\newlineF_{n-1}\\end{array}\\right] \\newline&amp;=\\ldots \\newline&amp;=A^{n-1}\\left[\\begin{array}{c}F_{1} \\newlineF_{2}\\end{array}\\right] \\newline&amp;=A^{n-1}\\left[\\begin{array}{c}1 \\newline1\\end{array}\\right]\\end{aligned}$$这样，我们就将这个问题转化为了某个矩阵的幂，接下来就可以用矩阵快速幂求解了： import java.util.Scanner; public class Matrix { long a1, a2, b1, b2; static final long mod = 1000000007; public Matrix(long a1, long a2, long b1, long b2) { this.a1 = a1; this.a2 = a2; this.b1 = b1; this.b2 = b2; } public Matrix addition(Matrix matrix) { return new Matrix(a1 * matrix.a1 + a2 * matrix.b1 % mod, a1 * matrix.a2 + a2 * matrix.b2 % mod, b1 * matrix.a1 + b2 * matrix.b1 % mod, b1 * matrix.a2 + b2 * matrix.b2 % mod); } public static Matrix matrixFastPower(Matrix matrix, long n) { Matrix ans = new Matrix(1, 0, 0, 1); while (n != 0) { if ((n &amp; 1) != 0) { ans = ans.addition(matrix); } matrix = matrix.addition(matrix); n &gt;&gt;= 1; } return ans; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(); Matrix m = new Matrix(0, 1, 1, 1); Matrix ans = matrixFastPower(m, x - 1); System.out.println((ans.a1 + ans.a2) % mod); } } 参考 [1] Pecco [2] 快速幂 [3] 同余定理 [4] 斐波那契数列","categories":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"快速幂","slug":"快速幂","permalink":"https://lemonsama123.gitee.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"矩阵","slug":"矩阵","permalink":"https://lemonsama123.gitee.io/tags/%E7%9F%A9%E9%98%B5/"}],"author":"Lemon"},{"title":"Java GUI","slug":"Java-GUI","date":"2021-12-14T13:13:40.000Z","updated":"2022-01-19T09:59:44.866Z","comments":true,"path":"posts/94bc9262.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/94bc9262.html","excerpt":"","text":"告诉大家该什么学？ 这是什么？ 它什么玩？ 该如何去在我们平时运用？ 组件 窗口 弹窗 面板 文本框 列表框 按钮 图片 监听事件 鼠标 键盘 破解工具 1、简介GUI 的核心：Swing 和 AWT 界面不美观 需要 JRE 环境 为什么要学习？ 了解 MVC 架构，了解监听 可以写出自己心中的一些小工具 工作的时候也可能需要维护到 Swing 界面（虽然概率不大） 2、AWT2.1 AWT 介绍 包含了很多类和接口，用于 GUI（图像用户编程）编程 包含很多元素：窗口、按钮、文本框等 java.awt 2.2 组件和容器1、Frameimport java.awt.*; public class FrameTest { public static void main(String[] args) { Frame frame = new Frame(\"第一个GUI界面\"); //设置窗口大小 frame.setSize(400, 400); //设置颜色 frame.setBackground(Color.GREEN); //设置弹出初始位置 frame.setLocation(200, 200); //设置大小固定 frame.setResizable(false); //必须设置可见性 frame.setVisible(true); } } 问题：无法关闭窗口，只能停止java程序 如何一次性输出多个frame 封装一个 JFrame 类，创建多个窗口import java.awt.*; public class MyFrameTest { public static void main(String[] args) { MyFrame myFrame1 = new MyFrame(100, 100, 200, 200, Color.blue); MyFrame myFrame2 = new MyFrame(300, 100, 200, 200, Color.YELLOW); MyFrame myFrame3 = new MyFrame(100, 300, 200, 200, Color.PINK); MyFrame myFrame4 = new MyFrame(300, 300, 200, 200, Color.MAGENTA); } } import java.awt.*; public class MyFrame extends Frame { static int count = 0; public MyFrame(int x, int y, int w, int h, Color color) { super(\"MyFrame\" + (++count)); setBackground(color); this.setVisible(true); this.setBounds(x, y, w, h); } } 2、面板（Panel）frame中放置一个固定面板 import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class PanelTest { public static void main(String[] args) { Frame frame = new Frame(); Panel panel = new Panel(); frame.setLayout(null); frame.setBounds(300, 300, 500, 500); frame.setBackground(new Color(0x43FF02)); //panel 坐标设置，相对于 frame panel.setBounds(50, 50, 400, 400); panel.setBackground(new Color(0xFFA2161B, true)); frame.add(panel); frame.setVisible(true); //事件监听，监听窗口结束 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 由于写了添加了事件监听器，所以点击关闭可以退出窗口 2.3 布局管理器1、流式布局import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class FlowLayoutTest { public static void main(String[] args) { Frame frame = new Frame(); //按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 frame.setLayout(new FlowLayout()); frame.setSize(200, 200); //添加按钮 frame.add(button1); frame.add(button2); frame.add(button3); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); frame.setVisible(true); } } 注意：流式布局默认为居中，如果想要靠左或靠右请将 frame.setLayout(new FlowLayout()); 改为 frame.setLayout(new FlowLayout(FlowLayout.LEFT)); 或 frame.setLayout(new FlowLayout(FlowLayout.RIGHT));，效果如下： 2、东南西北中import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class BorderLayoutTest { public static void main(String[] args) { Frame frame = new Frame(\"BorderLayoutTest\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east, BorderLayout.EAST); frame.add(west, BorderLayout.WEST); frame.add(south, BorderLayout.NORTH); frame.add(north, BorderLayout.SOUTH); frame.add(center, BorderLayout.CENTER); frame.setSize(200, 200); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); frame.setVisible(true); } } 3、表格布局（Grid）import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class GridLayoutTest { public static void main(String[] args) { Frame frame = new Frame(\"GridLayoutTest\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3, 2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); //自动填充 frame.pack(); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); frame.setVisible(true); } } 4、练习分析： import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class Exercise1 { public static void main(String[] args) { Frame frame = new Frame(); frame.setLayout(new GridLayout(2, 1)); Panel panel1 = new Panel(new BorderLayout()); Panel panel2 = new Panel(new GridLayout(2, 1)); Panel panel3 = new Panel(new BorderLayout()); Panel panel4 = new Panel(new GridLayout(2, 2)); panel1.add(new Button(\"East-1\"), BorderLayout.EAST); panel1.add(new Button(\"West-1\"), BorderLayout.WEST); panel2.add(new Button(\"p2-btn-1\")); panel2.add(new Button(\"p2-btn-2\")); panel1.add(panel2, BorderLayout.CENTER); panel3.add(new Button(\"East-2\"), BorderLayout.EAST); panel3.add(new Button(\"West-2\"), BorderLayout.WEST); for (int i = 0; i &lt; 4; i++) { panel4.add(new Button(\"for-\" + i)); } panel3.add(panel4); frame.add(panel1); frame.add(panel3); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); frame.pack(); frame.setVisible(true); } } 5、总结 Frame 是一个顶级窗口 Panel 无法单独显示，必须添加到某个容器中 布局管理器 流式 东西南北中 表格 大小、定位、背景颜色、可见性、监听 2.4 事件监听 事件监听：当某个事件发生的时候做点什么 关闭事件和单个按钮事件package com.lemonsama.lesson2; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class MyActionListener implements ActionListener { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"Test\"); } } package com.lemonsama.lesson2; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class MyActionListenerTest { public static void main(String[] args) { //按下按钮，触发事件 Frame frame = new Frame(\"ActionEventTest\"); Button button = new Button(); button.addActionListener(new MyActionListener()); frame.setLayout(new BorderLayout()); frame.add(button, BorderLayout.CENTER); frame.pack(); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); frame.setVisible(true); } public static void closeWindow(Frame frame) { frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 效果如下： 点击按钮后输出： 两个按钮和关闭事件import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class MyMonitor implements ActionListener { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"按钮被点击了：msg=&gt;\"+ e.getActionCommand()); } } import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ActionEventTest { public static void main(String[] args) { //开始按钮，实现同一个事件 //开始 停止 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); MyMonitor myMonitor = new MyMonitor(); //可以显示定义触发返回的命令，不写则返回 label 的值 //可以实现都个按钮只写一个监听类 button2.setActionCommand(\"button2-stop\"); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1, BorderLayout.NORTH); frame.add(button2, BorderLayout.SOUTH); frame.pack(); frame.setVisible(true); closeWindow(frame); } public static void closeWindow(Frame frame) { frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 效果如下： 分别点击 start 和 stop 按钮后输出如下： 2.5 输入框（TextField）监听import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class MyActionListener1 implements ActionListener { @Override public void actionPerformed(ActionEvent e) { TextField source = (TextField) e.getSource(); String text = source.getText(); System.out.println(text); //回车设置为空 source.setText(\"\"); } } import java.awt.*; public class MyFrame extends Frame { public MyFrame() { TextField textField = new TextField(); this.add(textField); MyActionListener1 myActionListener1 = new MyActionListener1(); textField.addActionListener(myActionListener1); //设置替换码 textField.setEchoChar('*'); this.setVisible(true); this.pack(); } } import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TextFieldTest { public static void main(String[] args) { MyFrame myFrame = new MyFrame(); closeWindow(myFrame); } public static void closeWindow(Frame frame) { frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 效果如下： 输入一些内容并回车： 2.6 简易计算器（加法）的实现import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class Calculator extends Frame { TextField textField1; TextField textField2; TextField textField3; public void loadFrame() { textField1 = new TextField(10); textField2 = new TextField(10); textField3 = new TextField(20); Button button = new Button(\"=\"); Label label = new Label(\"+\"); this.setLayout(new FlowLayout()); this.add(textField1); this.add(label); this.add(textField2); this.add(button); this.add(textField3); pack(); setVisible(true); button.addActionListener(new CalculatorListener()); closeWindow(this); } private class CalculatorListener implements ActionListener { @Override public void actionPerformed(ActionEvent e) { int a = Integer.parseInt(textField1.getText()); int b = Integer.parseInt(textField2.getText()); textField3.setText((a + b) + \"\"); textField1.setText(\"\"); textField2.setText(\"\"); } } public static void closeWindow(Frame frame) { frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } public class CalculatorTest { public static void main(String[] args) { Calculator calculator = new Calculator(); calculator.loadFrame(); } } 效果如下： 演示： 2.7 画笔import java.awt.*; public class MyPaint extends Frame { public void loadFrame() { setBounds(200, 200, 600, 500); setVisible(true); } @Override public void paint(Graphics g) { //画笔需要有颜色 g.setColor(Color.RED); g.drawOval(100, 100, 100, 100); g.fillOval(100, 100, 100, 100);//实心圆 g.setColor(Color.GREEN); g.fillRect(150, 200, 200, 200); //画笔用完，还原到最初的颜色 g.setColor(Color.BLACK); } } public class PaintTest { public static void main(String[] args) { new MyPaint().loadFrame(); } } 效果如下： 2.8 鼠标监听目的：鼠标画画 import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.util.ArrayList; import java.util.Iterator; public class MyFrame extends Frame { //画画需要画笔，需要监听鼠标的位置，需要集合来存储这个点 ArrayList points; //我的窗口 public MyFrame(String title) { super(title); setBounds(200, 200, 400, 400); //存鼠标点击的点 points = new ArrayList&lt;&gt;(); //鼠标监听器，针对与这个窗口 this.addMouseListener(new MyMouseListener()); setVisible(true); } //画笔事件 @Override public void paint(Graphics g) { //画画需要监听鼠标事件 Iterator iterator = points.iterator(); while (iterator.hasNext()) { Point next = (Point) iterator.next(); g.setColor(Color.BLUE); g.fillRect(next.x, next.y, 10, 10); } } //添加一个点到界面上 public void addPaint(Point point) { points.add(point); } //适配器模式 //鼠标监听器 private class MyMouseListener extends MouseAdapter { //鼠标点击 @Override public void mousePressed(MouseEvent e) { MyFrame myFrame = (MyFrame) e.getSource(); //我们在点击的时候，就会在界面上产生一个点 //这个点就是当前鼠标 myFrame.addPaint(new Point(e.getX(), e.getY())); //每次点击都需要刷新画笔重新画点 myFrame.repaint(); } } } import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class MouseListenerTest { public static void main(String[] args) { MyFrame myFrame = new MyFrame(\"画\"); shoutWindow(myFrame); } //窗口关闭监听器 public static void shoutWindow(Frame frame) { frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 效果如下： 2.9 窗口监听import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class WindowFream extends Frame { public WindowFream() { setBackground(Color.BLUE); setBounds(100, 100, 200, 200); setVisible(true); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { setVisible(false); System.exit(0); } }); } } public class WindowTest { public static void main(String[] args) { new WindowFream(); } } 2.10 键盘监听import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; public class KeyFrame extends Frame { public KeyFrame() { setBounds(1, 2, 300, 400); setVisible(true); this.addKeyListener(new KeyAdapter() { //键盘按下 @Override public void keyPressed(KeyEvent e) { //获取键盘码，可以计算出按下的键 int keyCode = e.getKeyCode(); if (keyCode == e.VK_UP) { System.out.println(\"你按下了上键\"); } } }); } } public class keyListenerTest { public static void main(String[] args) { new KeyFrame(); } } 效果如下： 按下上键后输出： 3、Swing3.1 窗口、面板import javax.swing.*; import java.awt.*; public class MyFrame extends JFrame { public void init() { this.setBounds(10, 10, 200, 300); this.setVisible(true); JLabel jLabel = new JLabel(\"JLabel\", JLabel.CENTER); this.add(jLabel); Container contentPane = this.getContentPane(); contentPane.setBackground(Color.BLUE); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } } public class JFrameTest { public static void main(String[] args) { new MyFrame().init(); } } 效果如下： 3.2 弹窗JDialog，弹窗，默认就有关闭事件 import javax.swing.*; import java.awt.*; public class MyDialog extends JDialog { public MyDialog() { this.setVisible(true); this.setBounds(100, 100, 500, 500); Container contentPane = this.getContentPane(); contentPane.add(new Label(\"this is a Label\")); } } import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class DialogTest extends JFrame { public DialogTest() { this.setVisible(true); setSize(700, 500); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //获取容器 Container contentPane = this.getContentPane(); //设置绝对布局 contentPane.setLayout(null); JButton jButton = new JButton(\"点击弹出一个对话框\"); jButton.setBounds(30, 30, 200, 50); jButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { new MyDialog(); } }); contentPane.add(jButton); } public static void main(String[] args) { new DialogTest(); } } 效果如下： 3.3 标签(label)icon 图标(可以放在标签中也可以放在按钮中)，可以自己绘制放到标签中 import javax.swing.*; import java.awt.*; public class IconTest extends JFrame implements Icon { private int width; private int height; public IconTest() {} public IconTest(int width, int height) { this.width = width; this.height = height; } public void init() { IconTest iconTest = new IconTest(15, 15); JLabel jLabel = new JLabel(\"IconTest\", iconTest, SwingConstants.CENTER); Container contentPane = this.getContentPane(); contentPane.add(jLabel); this.setVisible(true); this.setBounds(100, 100, 300, 300); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconTest().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x, y, this.width, this.height); } @Override public int getIconWidth() { return this.width; } @Override public int getIconHeight() { return this.height; } } 效果如图： 可以将图片当做图标来使用 ImageIcon import javax.swing.*; import java.awt.*; import java.net.URL; public class MyImageIcon extends JFrame { public MyImageIcon() { JLabel jLabel = new JLabel(\"ImageIcon\"); URL resource = MyImageIcon.class.getResource(\"1640404870375.png\"); ImageIcon imageIcon = new ImageIcon(resource); jLabel.setIcon(imageIcon); jLabel.setHorizontalAlignment(SwingConstants.CENTER); Container contentPane = getContentPane(); contentPane.add(jLabel); setBounds(100, 100, 200, 200); setVisible(true); setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new MyImageIcon(); } } 效果如下： 3.4 面板JPanel import javax.swing.*; import java.awt.*; public class MyJPanel extends JFrame { public MyJPanel() { Container contentPane = this.getContentPane(); contentPane.setLayout(new GridLayout(2, 1, 10, 10)); JPanel jPanel1 = new JPanel(new GridLayout(1, 3)); JPanel jPanel2 = new JPanel(new GridLayout(1, 2)); JPanel jPanel3 = new JPanel(new GridLayout(2, 1)); JPanel jPanel4 = new JPanel(new GridLayout(3, 2)); jPanel1.add(new Button(\"1\")); jPanel1.add(new Button(\"1\")); jPanel1.add(new Button(\"1\")); jPanel2.add(new Button(\"2\")); jPanel2.add(new Button(\"2\")); jPanel3.add(new Button(\"3\")); jPanel3.add(new Button(\"3\")); jPanel4.add(new Button(\"4\")); jPanel4.add(new Button(\"4\")); jPanel4.add(new Button(\"4\")); jPanel4.add(new Button(\"4\")); jPanel4.add(new Button(\"4\")); jPanel4.add(new Button(\"4\")); contentPane.add(jPanel1); contentPane.add(jPanel2); contentPane.add(jPanel3); contentPane.add(jPanel4); this.setVisible(true); this.setSize(500, 500); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new MyJPanel(); } } JScrollPanel，滚动条面板 import javax.swing.*; import java.awt.*; public class JScrollTest extends JFrame { public JScrollTest() { Container contentPane = this.getContentPane(); //文本域 JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(\"文本框\"); JScrollPane jScrollPane = new JScrollPane(jTextArea); contentPane.add(jScrollPane); this.setVisible(true); this.setBounds(100, 100, 300, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new JScrollTest(); } } 效果如下： 3.5 按钮自定义图片标签按钮import javax.swing.*; import java.awt.*; import java.net.URL; public class JButtonTest extends JFrame { public JButtonTest() { Container contentPane = this.getContentPane(); URL resource = JButtonTest.class.getResource(\"1640404870375.png\"); Icon Icon = new ImageIcon(resource); JButton button = new JButton(); button.setIcon(Icon); button.setToolTipText(\"图片按钮\"); contentPane.add(button); this.setSize(500, 300); this.setVisible(true); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { new JButtonTest(); } } 效果如下： 单选按钮import javax.swing.*; import java.awt.*; import java.net.URL; public class JButtonTest2 extends JFrame { public JButtonTest2() { Container contentPane = this.getContentPane(); URL resource = JButtonTest2.class.getResource(\"1640404870375.png\"); Icon Icon = new ImageIcon(resource); JRadioButton jRadioButton1 = new JRadioButton(\"JRadioButton01\"); JRadioButton jRadioButton2 = new JRadioButton(\"JRadioButton02\"); JRadioButton jRadioButton3 = new JRadioButton(\"JRadioButton03\"); //由于单选框只能选择一个，一般分组，一个组中只能选择一个 ButtonGroup buttonGroup = new ButtonGroup(); buttonGroup.add(jRadioButton1); buttonGroup.add(jRadioButton2); buttonGroup.add(jRadioButton3); contentPane.add(jRadioButton1, BorderLayout.CENTER); contentPane.add(jRadioButton2, BorderLayout.NORTH); contentPane.add(jRadioButton3, BorderLayout.SOUTH); this.setSize(500, 300); this.setVisible(true); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { new JButtonTest2(); } } 效果如下： 复选按钮import javax.swing.*; import java.awt.*; import java.net.URL; public class JButtonTest3 extends JFrame { public JButtonTest3() { Container contentPane = this.getContentPane(); URL resource = JButtonTest3.class.getResource(\"1640404870375.png\"); Icon Icon = new ImageIcon(resource); JCheckBox checkBox1 = new JCheckBox(\"checkBox01\"); JCheckBox checkBox2 = new JCheckBox(\"checkBox02\"); contentPane.add(checkBox1, BorderLayout.NORTH); contentPane.add(checkBox2, BorderLayout.SOUTH); this.setSize(500, 300); this.setVisible(true); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { new JButtonTest3(); } } 效果如下： 3.6 列表下拉框import javax.swing.*; import java.awt.*; public class ComboboxTest01 extends JFrame { public ComboboxTest01() { Container contentPane = this.getContentPane(); JComboBox status = new JComboBox(); status.addItem(null); status.addItem(\"正在上映\"); status.addItem(\"已下架\"); status.addItem(\"即将上映\"); contentPane.add(status); this.setVisible(true); this.setSize(500, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new ComboboxTest01(); } } 效果如下： 列表框import javax.swing.*; import java.awt.*; public class ComboboxTest02 extends JFrame { public ComboboxTest02() { Container contentPane = this.getContentPane(); String[] contents = {\"1\", \"2\", \"3\"}; JList jList = new JList(contents); contentPane.add(jList); this.setVisible(true); this.setSize(500, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new ComboboxTest02(); } } 效果如下： 3.7 文本框文本框import javax.swing.*; import java.awt.*; public class TextTest01 extends JFrame { public TextTest01() { Container contentPane = this.getContentPane(); JTextField jTextField1 = new JTextField(\"hello\"); JTextField jTextField2 = new JTextField(\"world\", 20); contentPane.add(jTextField1, BorderLayout.NORTH); contentPane.add(jTextField2, BorderLayout.SOUTH); this.setVisible(true); this.setSize(500, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new TextTest01(); } } 效果如下： 密码框import javax.swing.*; import java.awt.*; public class TextTest02 extends JFrame { public TextTest02() { Container contentPane = this.getContentPane(); JPasswordField jPasswordField = new JPasswordField(); jPasswordField.setEchoChar('*'); contentPane.add(jPasswordField); this.setVisible(true); this.setSize(500, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new TextTest02(); } } 效果如下： 文本域import javax.swing.*; import java.awt.*; public class TextTest03 extends JFrame { public TextTest03() { Container contentPane = this.getContentPane(); //文本域 JTextArea jTextArea = new JTextArea(20, 50); jTextArea.setText(\"文本框\"); JScrollPane jScrollPane = new JScrollPane(jTextArea); contentPane.add(jScrollPane); this.setVisible(true); this.setBounds(100, 100, 300, 350); this.setDefaultCloseOperation(EXIT_ON_CLOSE); } public static void main(String[] args) { new TextTest03(); } } 效果如下：","categories":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"GUI","slug":"GUI","permalink":"https://lemonsama123.gitee.io/tags/GUI/"},{"name":"AWT","slug":"AWT","permalink":"https://lemonsama123.gitee.io/tags/AWT/"},{"name":"Swing","slug":"Swing","permalink":"https://lemonsama123.gitee.io/tags/Swing/"}],"author":"Lemon"},{"title":"JDBC","slug":"JDBC","date":"2021-12-14T12:45:27.000Z","updated":"2022-03-22T06:51:19.314Z","comments":true,"path":"posts/8fe47ff4.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/8fe47ff4.html","excerpt":"","text":"第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一@Test public void testConnection1() { try { //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = \"jdbc:mysql://localhost:3306/test\"; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"abc123\"); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); } catch (SQLException e) { e.printStackTrace(); } } 说明：上述代码中显式出现了第三方数据库的API 2.4.2 连接方式二@Test public void testConnection2() { try { //1.实例化Driver String className = \"com.mysql.jdbc.Driver\"; Class clazz = Class.forName(className); Driver driver = (Driver) clazz.newInstance(); //2.提供url，指明具体操作的数据 String url = \"jdbc:mysql://localhost:3306/test\"; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"abc123\"); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三@Test public void testConnection3() { try { //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"abc123\"; String driverName = \"com.mysql.jdbc.Driver\"; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四@Test public void testConnection4() { try { //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"abc123\"; String driverName = \"com.mysql.jdbc.Driver\"; //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); } } */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 2.4.5 连接方式五(最终版)@Test public void testConnection5() throws Exception { //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 其中，配置文件声明在工程的src目录下：【jdbc.properties】 user=root password=abc123 url=jdbc:mysql://localhost:3306/test driverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。 第3章：使用PreparedStatement实现CRUD操作3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE ResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： public class StatementTest { // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() { Scanner scan = new Scanner(System.in); System.out.print(\"用户名：\"); String userName = scan.nextLine(); System.out.print(\"密 码：\"); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = '1' or ' AND PASSWORD = '='1' or '1' = '1'; String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password + \"'\"; User user = get(sql, User.class); if (user != null) { System.out.println(\"登陆成功!\"); } else { System.out.println(\"用户名或密码错误！\"); } } // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) { T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try { // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭资源 if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null) { try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return null; } } 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 3.3.4 使用PreparedStatement实现增、删、改操作//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） public void update(String sql,Object ... args){ Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++){ ps.setObject(i + 1, args[i]); } //4.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); }finally{ //5.关闭资源 JDBCUtils.closeResource(conn, ps); } } 3.3.5 使用PreparedStatement实现查询操作// 通用的针对于不同表的查询:返回一个对象 (version 1.0) public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) { T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) {// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); } return null; } 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型//获取连接 Connection conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth,photo)values(?,?,?,?)\"; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 ps.setString(1, \"徐海强\"); ps.setString(2, \"xhq@126.com\"); ps.setDate(3, new Date(new java.util.Date().getTime())); // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\"xhq.png\"); ps.setBlob(4, fis); //执行 ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段Connection conn = JDBCUtils.getConnection(); String sql = \"update customers set photo = ? where id = ?\"; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\"coffee.png\"); ps.setBlob(1, fis); ps.setInt(2, 25); ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型String sql = \"SELECT id, name, email, birth, photo FROM customer WHERE id = ?\"; conn = getConnection(); ps = conn.prepareStatement(sql); ps.setInt(1, 8); rs = ps.executeQuery(); if(rs.next()){ Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 Blob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(\"c.jpg\"); byte [] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); } JDBCUtils.closeResource(conn, ps, rs); if(is != null){ is.close(); } if(os != null){ os.close(); } } 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： CREATE TABLE goods( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); 5.2.1 实现层次一：使用StatementConnection conn = JDBCUtils.getConnection(); Statement st = conn.createStatement(); for(int i = 1;i &lt;= 20000;i++){ String sql = \"insert into goods(name) values('name_' + \"+ i +\")\"; st.executeUpdate(sql); } 5.2.2 实现层次二：使用PreparedStatementlong start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 20000;i++){ ps.setString(1, \"name_\" + i); ps.executeUpdate(); } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//82340 JDBCUtils.closeResource(conn, ps); 5.2.3 实现层次三/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */ @Test public void testInsert1() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//20000条：625 //1000000条:14733 JDBCUtils.closeResource(conn, ps); } 5.2.4 实现层次四/* * 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */ @Test public void testInsert2() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps); } 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 public void testJDBCTransaction() { Connection conn = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql1, \"AA\"); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql2, \"BB\"); // 4.若没有异常，则提交事务 conn.commit(); } catch (Exception e) { e.printStackTrace(); // 5.若有异常，则回滚事务 try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } //7.关闭连接 JDBCUtils.closeResource(conn, null, null); } } 其中，对数据库操作的方法为： //使用事务以后的通用的增删改操作（version 2.0） public void update(Connection conn ,String sql, Object... args) { PreparedStatement ps = null; try { // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 4.关闭资源 JDBCUtils.closeResource(null, ps); } } 6.3 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： create user tom identified by 'abc123'; 授予权限 #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123. grant all privileges on *.* to tom@'%' identified by 'abc123'; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123'; 第7章：DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】package com.atguigu.bookstore.dao; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.Connection; import java.sql.SQLException; import java.util.List; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; /** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */ public abstract class BaseDao&lt;T&gt; { private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() { // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; } /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) { int count = 0; try { count = queryRunner.update(conn, sql, params); } catch (SQLException e) { e.printStackTrace(); } return count; } /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) { T t = null; try { t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return t; } /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) { List&lt;T&gt; list = null; try { list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return list; } /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) { Object count = null; try { // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); } catch (SQLException e) { e.printStackTrace(); } return count; } } 【BookDAO.java】package com.atguigu.bookstore.dao; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; public interface BookDao { /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice); } 【UserDAO.java】package com.atguigu.bookstore.dao; import java.sql.Connection; import com.atguigu.bookstore.beans.User; public interface UserDao { /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user); } 【BookDaoImpl.java】package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.BookDao; public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao { @Override public List&lt;Book&gt; getBooks(Connection conn) { // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\"; beanList = getBeanList(conn,sql); return beanList; } @Override public void saveBook(Connection conn,Book book) { // 写sql语句 String sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); } @Override public void deleteBookById(Connection conn,String bookId) { // 写sql语句 String sql = \"DELETE FROM books WHERE id = ?\"; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); } @Override public Book getBookById(Connection conn,String bookId) { // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\"; book = getBean(conn,sql, bookId); return book; } @Override public void updateBook(Connection conn,Book book) { // 写sql语句 String sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); } @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) { // 获取数据库中图书的总记录数 String sql = \"select count(*) from books\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) { // 获取数据库中图书的总记录数 String sql = \"select count(*) from books where price between ? and ?\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } } 【UserDaoImpl.java】package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import com.atguigu.bookstore.beans.User; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.UserDao; public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao { @Override public User getUser(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ? and password = ?\"; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; } @Override public boolean checkUsername(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ?\"; bean = getBean(conn,sql, user.getUsername()); return bean != null; } @Override public void saveUser(Connection conn,User user) { //写sql语句 String sql = \"insert into users(username,password,email) values(?,?,?)\"; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); } } 【Book.java】package com.atguigu.bookstore.beans; /** * 图书类 * @author songhongkang * */ public class Book { private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = \"static/img/default.jpg\"; // 封面图片的路径 //构造器，get()，set()，toString()方法略 } 【Page.java】package com.atguigu.bookstore.beans; import java.util.List; /** * 页码类 * @author songhongkang * */ public class Page&lt;T&gt; { private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页 // private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】package com.atguigu.bookstore.beans; /** * 用户类 * @author songhongkang * */ public class User { private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 //使用C3P0数据库连接池的方式，获取数据库的连接：不推荐 public static Connection getConnection1() throws Exception{ ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(\"com.mysql.jdbc.Driver\"); cpds.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); cpds.setUser(\"root\"); cpds.setPassword(\"abc123\"); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn; } 获取连接方式二 //使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource cpds = new ComboPooledDataSource(\"helloc3p0\"); public static Connection getConnection2() throws SQLException{ Connection conn = cpds.getConnection(); return conn; } 其中，src下的配置文件为：【c3p0-config.xml】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;c3p0-config&gt; &lt;named-config name=\"helloc3p0\"&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;abc123&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=\"minPoolSize\"&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=\"maxStatements\"&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： public static Connection getConnection3() throws Exception { BasicDataSource source = new BasicDataSource(); source.setDriverClassName(\"com.mysql.jdbc.Driver\"); source.setUrl(\"jdbc:mysql:///test\"); source.setUsername(\"root\"); source.setPassword(\"abc123\"); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn; } 获取连接方式二： //使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource source = null; static{ try { Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\"dbcp.properties\"); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection4() throws Exception { Connection conn = source.getConnection(); return conn; } 其中，src下的配置文件为：【dbcp.properties】 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false username=root password=abc123 initialSize=10 #... 8.3.3 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 package com.atguigu.druid; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; public class TestDruid { public static void main(String[] args) throws Exception { Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\")); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); } } 其中，src下的配置文件为：【druid.properties】 url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true username=root password=123456 driverClassName=com.mysql.jdbc.Driver initialSize=10 maxActive=20 maxWait=1000 filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… 测试 // 测试添加 @Test public void testInsert() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; int count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\"); System.out.println(\"添加了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null); } // 测试删除 @Test public void testDelete() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"delete from customers where id &lt; ?\"; int count = runner.update(conn, sql,3); System.out.println(\"删除了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null); } 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 /* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */ @Test public void testQueryInstance() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */ @Test public void testQueryList() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null); } /* * 自定义ResultSetHandler的实现类 */ @Test public void testQueryInstance1() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() { @Override public Customer handle(ResultSet rs) throws SQLException { System.out.println(\"handle\"); // return new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L)); if(rs.next()){ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customer(id, name, email, birth); } return null; } }; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */ @Test public void testQueryValue() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一： // String sql = \"select count(*) from customers where id &lt; ?\"; // ScalarHandler handler = new ScalarHandler(); // long count = (long) runner.query(conn, sql, handler, 20); // System.out.println(count); //测试二： String sql = \"select max(birth) from customers\"; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null); } JDBC总结总结 @Test public void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 } }","categories":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://lemonsama123.gitee.io/tags/JDBC/"}],"author":"Lemon"},{"title":"异常处理","slug":"异常处理","date":"2021-12-14T11:21:37.000Z","updated":"2022-01-19T06:14:39.066Z","comments":true,"path":"posts/28877bf.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/28877bf.html","excerpt":"","text":"一、异常处理1.1 异常概述与异常体系结构在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如： 客户输入数据的格式、读取文件是否存在、网络是否始终保持通畅等等 异常 ：在Java语言中将程序执行中发生的不正常情况称为异常 。（开发过程中的语法错误和逻辑错误不是异常） Java 程序在执行过程中所发生的异常事件可分为两类： Error：Java 虚拟机无法解决的严重问题 。如： JVM系统内部错误 、资源耗尽等严重情况。比如：StackOverflowError和OutOfMemoryError。 一般不编写针对性的代码进行处理 Exception：其它因编程错误或偶然的外在因素导致的一般性问题可以使用针对性的代码进行处理 。 例如：空指针访问、试图读取不存在的文件、网络连接中断、数组下标越界 对于这些错误 一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时就考虑到错误的检测 、 错误消息的提示 以及错误的处理。 捕获错误最理想的是在编译期间， 但有的错误只有在运行时才会发生 。比如：除数为0、数组下标越界等 分类： 编译时异常和运行时异常 运行时异常： 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 java.lang.RuntimeException类及它的子类都是运行时异常 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响 编译时异常： 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。 编译器要求Java程序必须捕获或声明所有编译时异常 对于这类异常，如果程序不处理，可能会带来意想不到的结果 1.2 常见异常 java.lang.RuntimeException NullPointerException ArrayIndexOutOfBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException …… java.io.IOExeption FileNotFoundException EOFException java.lang.ClassNotFoundException java.lang.InterruptedException java.io.FileNotFoundException java.sql.SQLException 1.2.1 常见异常之ArrayIndexOutOfBoundsException（数组下标越界异常）public class IndexOutExp { public static void main(String[] args) { String[] friends = {\"lisa\", \"bily\", \"kessy\"}; for (int i = 0; i &lt; 5; i++) { System.out.println(friends[i]); //不存在friends[4] } System.out.println(\"\\nthis is the end\"); } } 程序IndexOutExp.java编译正确，运行结果： 1.2.2 常见异常之NullPointerException（空指针异常）public class NullRef { int i = 1; public static void main(String[] args) { NullRef t = new NullRef(); t = null; System.out.println(t); } } 程序NullRef.java编译正确，运行结果： 1.2.3 常见异常之ArithmeticException（算术运算异常）public class DivideZero { int x; public static void main(String[] args) { int y; DivideZero c = new DivideZero(); y = 3 / c.x; //除数为0 System.out.println(\"program ends OK!\"); } } 程序ArithmeticException.java编译正确，运行结果： 1.2.4 常见异常之ClassCastException（类型匹配异常）public class Order { public static void main(String[] args) { Object obj = new Date(); Order order; order = (Order) obj; System.out.println(order); } } 程序Order.java编译正确，运行结果： 1.3 异常处理机制一：try-catch-finally Java 提供的是异常处理的抓抛模型 Java 程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给 Java 运行时系统，这个过程称为抛出异常 异常对象的生成 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出，自动抛出 由开发人员手动创建：Exception exception = new ClassCastException();创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象 一样 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法 。这个过程将一直继续下去，直到异常被处理 。这一过程称为捕获异常 如果一个异常回到 main() 方法并且 main() 也不处理则程序运行终止 程序员通常只能处理 Exception，而对 Error 无能为力 异常处理是通过 try-catch-finally 语句实现的: try { 可能产生异常的代码 } catch (ExceptionName1 e) { 当产生ExceptionName1型异常时的处置措施 } catch (ExceptionName e) { 当产生ExceptionName1型异常时的处置措施 } [finally { 无论是否发生异常都要执行的语句 }] try 捕获异常的第一步是用try{ }语句块选定捕获异常的范围，将可能出现异常的代码放在 try 语句块中 catch (Exceptiontype e) 在 catch 语句块中是对异常对象进行处理的代码。每个 try 语句块可以伴随一个或多个 catch语句用于处理可能产生的不同类型的异常对象 捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法 getMessage()：获取异常信息，返回字符串 printStackTrace()：获取异常类名和异常信息，以及异常出现在程序中的位置。返回值 为void finally 捕获异常的最后一步是通过 finally 语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理 不论在 try 代码块中是否发生了异常事件，catch 语句是否执行，catch 语句是否有异常， catch 语句中是否有 return，finally 块中的语句都会被执行 finally 语句和 catch 语句是任选的 1.3.1 举例例一： public class IndexOutExp { public static void main(String[] args) { String friends[] = {\"lisa\", \"bily\", \"kessy\"}; try { for (int i = 0; i &lt; 5; i++) { System.out.println(friends[i]); } } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"index err\"); } System.out.println(\"\\nthis is the end\"); } } 运行结果如下： 例二： public class DivideZero { int x; public static void main(String[] args) { int y; DivideZero c = new DivideZero(); try { y = 3 / c.x; } catch (ArithmeticException e) { System.out.println(\"divide by zero error!\"); } System.out.println(\"program ends OK!\"); } } 运行结果如下： 1.3.2 不捕获异常时的情况 前面使用的异常都是 RuntimeException 类或是它的子类，这些类的异常的特点是：即使没有使用 try 和 catch 捕获，Java 自己也能捕获，并且编译通过，但运行时会发生异常使得程序运行终止 如果抛出的异常是 IOException 等类型的非运行时异常，则 必须捕获，否则编译错误 。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 IOException异常处理举例import java.io.File; import java.io.FileInputStream; public class IOExp { public static void main(String[] args) { FileInputStream in = new FileInputStream(\"test.txt\"); int b; b = in.read(); while (b != -1) { System.out.print((char)b); b = in.read(); } in.close(); } } import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class IOExp { public static void main(String[] args) { try { FileInputStream in = new FileInputStream(\"test.txt\"); int b; b = in.read(); while (b != -1) { System.out.print((char) b); b = in.read(); } in.close(); } catch (IOException e) { System.out.println(e); } finally { System.out.println(\" It`s Ok!\"); } } } 1.4 异常处理机制二：throw 申明抛出异常是 Java 中处理异常的第二种方式 如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的 调用者 负责处理 在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型也可以是它的父类 例： import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class ThrowsTest { public static void main(String[] args) { } public void readFile() throws IOException { File file; FileInputStream in = new FileInputStream(\"test.txt\"); int b; b = in.read(); while (b != 1) { System.out.println((char)b ); b = in.read(); } in.close(); } } 1.4.1 重写方法声明抛出异常的原则 重写方法不能抛出比被重写方法范围更大的异常类型。 在多态的情况下对 methodA 方法的调用 异常的捕获按父类声明的异常处理 1.5 手动抛出异常 Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出 首先要生成异常类对象，然后通过 throw 语句实现抛出操作 可以抛出的异常必须是 Throwable 或其子类的实例。下面的语句在编译时将会产生语法错误 1.6 用户自定义异常类 一般地，用户自定义异常类都是 RuntimeException的 子类 自定义异常类通常需要编写几个重载的构造器 自定义异常需要提供 serialVersionUID 自定义的异常通过 throw 抛出 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型 用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类 public class MyException extends Exception { static final long serialVersionUID = -3387516993124229948L; private int idnumber; public MyException(String message, int idnumber) { super(message); this.idnumber = idnumber; } public int getId() { return idnumber; } } class MyExpTest { public void regist(int num) throws MyException { if (num &lt; 0) { throw new MyException(\"人数为负值，不合理\", 3); } else { System.out.println(\"登记人数\" + num); } } public void manager() { try { regist(100); } catch (MyException e) { System.out.println(\"登记失败，出错种类\" + e.getId()); } System.out.println(\"本次登记操作结束\"); } public static void main(String[] args) { MyExpTest t = new MyExpTest(); t.manager(); } } 1.6 总结 1.6.1 异常1. 异常的体系结构* java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。 * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked) * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException * |-----ArrayIndexOutOfBoundsException * |-----ClassCastException * |-----NumberFormatException * |-----InputMismatchException * |-----ArithmeticException 2. 从程序执行过程，看编译时异常和运行时异常 编译时异常：执行javac.exe命名时，可能出现的异常运行时异常：执行java.exe命名时，出现的异常 3 常见的异常类型，请举例说明：//******************以下是运行时异常*************************** //ArithmeticException @Test public void test6(){ int a = 10; int b = 0; System.out.println(a / b); } //InputMismatchException @Test public void test5(){ Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(score); scanner.close(); } //NumberFormatException @Test public void test4(){ String str = \"123\"; str = \"abc\"; int num = Integer.parseInt(str); } //ClassCastException @Test public void test3(){ Object obj = new Date(); String str = (String)obj; } //IndexOutOfBoundsException @Test public void test2(){ //ArrayIndexOutOfBoundsException // int[] arr = new int[10]; // System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = \"abc\"; System.out.println(str.charAt(3)); } //NullPointerException @Test public void test1(){ // int[] arr = null; // System.out.println(arr[3]); String str = \"abc\"; str = null; System.out.println(str.charAt(0)); } //******************以下是编译时异常*************************** @Test public void test7(){ // File file = new File(\"hello.txt\"); // FileInputStream fis = new FileInputStream(file); // // int data = fis.read(); // while(data != -1){ // System.out.print((char)data); // data = fis.read(); // } // // fis.close(); } 1.6.2 异常的处理1. java异常处理的抓抛模型过程一：\"抛\"：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 * 并将此对象抛出。 * 一旦抛出对象以后，其后的代码就不再执行。 * * 关于异常对象的产生：① 系统自动生成的异常对象 * ② 手动的生成一个异常对象，并抛出（throw） * 过程二：\"抓\"：可以理解为异常的处理方式：① try-catch-finally ② throws 2. 异常处理方式一：try-catch-finally2.1 使用说明：try{ * //可能出现异常的代码 * * }catch(异常类型1 变量名1){ * //处理异常的方式1 * }catch(异常类型2 变量名2){ * //处理异常的方式2 * }catch(异常类型3 变量名3){ * //处理异常的方式3 * } * .... * finally{ * //一定会执行的代码 * } * * 说明： * 1. finally是可的。 * 2. 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 * 3. 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码 * 4. catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。 * catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 * 5. 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() * 6. 在try结构中声明的变量，再出了try结构以后，就不能再被调用 * 7. try-catch-finally结构可以嵌套 总结：如何看待代码中的编译时异常和运行时异常？ * 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 * * 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 2.2 finally的再说明：* 1.finally是可选的 * * 2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 * * 3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 2.3 面试题final、finally、finalize三者的区别？ 类似： throw 和 throws Collection 和 Collections String 、StringBuffer、StringBuilder ArrayList 、 LinkedList HashMap 、LinkedHashMap 重写、重载 结构不相似的： 抽象类、接口 、 equals() sleep()、wait() 3. 异常处理方式二：\"throws + 异常类型\"写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ 4. 对比两种处理方式try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 5. 体会开发中应该如何选择两种处理方式？* 5.1 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 * 5.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充： 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 1.6.3 手动抛出异常对象1. 使用说明在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。 2. 面试题]throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 3. 典型例题class Student{ private int id; public void regist(int id) throws Exception { if(id &gt; 0){ this.id = id; }else{ //手动抛出异常对象 // throw new RuntimeException(\"您输入的数据非法！\"); // throw new Exception(\"您输入的数据非法！\"); throw new MyException(\"不能输入负数\"); } } @Override public String toString() { return \"Student [id=\" + id + \"]\"; } } 1.6.4 自定义异常类如何自定义一个异常类？ /* * 如何自定义异常类？ * 1. 继承于现的异常结构：RuntimeException 、Exception * 2. 提供全局常量：serialVersionUID * 3. 提供重载的构造器 * */ public class MyException extends Exception{ static final long serialVersionUID = -7034897193246939L; public MyException(){ } public MyException(String msg){ super(msg); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://lemonsama123.gitee.io/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"多线程","slug":"多线程","date":"2021-12-14T11:19:06.000Z","updated":"2022-01-28T14:53:34.960Z","comments":true,"path":"posts/5729df21.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/5729df21.html","excerpt":"","text":"一、基本概念：程序、进程、线程 程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码 ，静态对象 进程(process)：是程序的一次执行过程，或是正在运行的一个程序。是 一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位， 系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程，==是一个程序内部的一条执行路径 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小 一个进程中的多个线程共享相同的内存单元/内存地址空间，它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱， 那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。 但是因为CPU时间单元特别短，因此感觉不出来 如果是多核的话，才能更好的发挥多线程的效率（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程、gc()垃圾回收线程、异常处理线程。当然如果发生异常，会影响主线程。 并行与并发 并行：多 个CPU同时执行多个任务。比如：多个人同时做不同的事 并发：一 个CPU（采用时间片）“同时”执行多个任务。比如：秒杀、多个人做同一件事 1.1 使用多线程的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 1.2 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等 需要 一些后台运行的程序时 二、线程的创建和使用 Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现 Thread 类的特性 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 通过该Thread对象的start()方法来启动这个线程，而非直接调用run() 2.1 Thread类 构造器 Thread()：创建新的Thread对象 Thread(String threadname)：创建线程并指定线程实例名 Thread(Runnable target)：指定创建线程的目标对象，它实现了 Runnable接口中的run()方法 Thread(Runnable target, String name)：创建新的Thread对象 2.2 API中创建线程的两种方式 JDK1.5之前创建新执行线程有两种方法 继承Thread类的方式 实现Runnable接口的方式 2.2.1 方式一：继承Thread类 定义子类继承 Thread 类 子类中重写Thread类中的run()方法 创建Thread子类对象，即创建了线程对象 调用线程对象start()方法：启动线程，调用run()方法 class MyThread extends Thread { public void run() { for (int i = 0; i &lt; 100; i += 2) { System.out.println(i); } } } public class ThreadTest { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 注意点： 如果自己手动调用run() 方法，那么就只是普通方法，没有启动多线程模式 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定 想要启动多线程，必须调用start方法 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出IllegalThreadStateException异常 2.2.2 方式二：实现Runnable接口 定义 子类 ，实现Runnable接口 子类中重写Runnable接口中的run()方法 通过Thread类含参构造器创建线程对象 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中 调用Thread类的start()方法：开启线程调用Runnable子类接口的run()方法 2.2.3 继承方式和实现方式的联系与区别 区别 继承Thread：线程代码存放Thread子类run()方法中 实现Runnable：线程代码存在接口的子类的run()方法 联系 public class Thread implements Runnable 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。 实现方式的好处 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源 2.3 Thread类的有关方法2.3.1 Thread类的有关方法(1) void start()：启动线程，并执行对象的run()方法 run()：线程在被调度时执行的操作 String getName()：返回线程的名称 void setName(String name)：设置该线程名称 static Thread currentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 ​ 2.3.2 Thread类的有关方法(2) static void yield()：线程让步 释放当前线程CPU时间片 若队列中没有同优先级的线程，忽略此方法 join()：当某个程序执行流中调用其他线程的join()方法时，调用线程将 被阻塞，直到join()方法加入的join线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis)：(指定时间：毫秒) 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队 抛出InterruptedException异常 stop()：强制线程生命期结束，不推荐使用 boolean isAlive()： 返回boolean，判断线程是否还活着 2.4 线程的调度 调度策略 时间片 抢占式：高优先级的线程抢占CPU Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 2.5 线程的优先级 线程的优先级等级 MAX_PRIORITY：10 MIN PRIORITY：1 NORM_PRIORITY：5 涉及的方法 getPriority()：返回线程优先值 setPriority (int newPriority)：改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 2.6 补充：线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon (true)可以把一个用户线程变成一个守护线程 Java垃圾回收就是一个典型的守护线程 若 JVM 中都是守护线程，当前JVM将退出 形象理解： 兔死狗烹，鸟尽弓藏 三、线程的生命周期 JDK中用Thread State类定义了线程的几种状态。要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态： 新建：当 一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时便进入运行状态，run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 四、线程的同步 问题的提出： 多个线程执行的不确定性引起执行结果的不稳定 多个线程 对 账本 的 共享，会造成操作的不完整性，会破坏数据 4.1 引例模拟火车站售票程序，开启三个窗口售票 public class Ticket implements Runnable { private int tick = 100; @Override public void run() { while (true) { if (tick &gt; 0) { System.out.println(Thread.currentThread().getName() + \"售出车票，tick号为\" + tick--); } else { break; } } } } class TicketDemo { public static void main(String[] args) { Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); t1.setName(\"t1窗口\"); t2.setName(\"t2窗口\"); t3.setName(\"t3窗口\"); t1.start(); t2.start(); t3.start(); } } 4.2 多线程安全问题private int tick = 100; @Override public void run() { while (true) { if (tick &gt; 0) { System.out.println(Thread.currentThread().getName() + \"售出车票，tick号为\" + tick--); } else { break; } } } 对于以上代码，出现了安全问题 问题的原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误 解决办法： 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行 4.3 Synchronized的使用方法Java对于多线程的安全问题提供了专业的解决方式：同步机制 同步代码块 synchronized(对象) { 需要被同步的代码 } 同步方法 public synchronized void show(String name) { ... } 4.4 同步机制中的锁 同步锁机制: 在《Thinking in Java》中是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法，就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了,而在其被解锁之时，另一个任务就可以锁定并使用它了 synchronized 的锁是什么 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器） 同步方法的锁：静态方法（类名 class） 、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为 this 或类名.class 注意： 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this） 4.5 同步的范围4.5.1 如何找问题，即代码是否存在线程安全 明确哪些代码是多线程运行的代码 明确多个线程是否有共享数据 明确多线程运行代码中是否有多条语句操作共享数据 4.5.2 如何解决呢对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中 4.5.3 切记 范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能 4.6 释放锁的操作 当前线程的同步方法、同步代码块执行结束 当前线程在同步代码块、同步方法中遇到 break 、 return 终止了该代码块、该方法的继续执行 当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception 导致异常结束 当前线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁 4.7 不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用 Thread.sleep 、Thread.yield 方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁（同步监视器） 4.8 单例设计模式之懒汉式（线程安全）public class Singleton { private static Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } class SingletonTest { public static void main(String[] args) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2); } } 4.9 线程的死锁问题 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 举例： public class DeadLockTest { public static void main(String[] args) { final StringBuffer s1 = new StringBuffer(); final StringBuffer s2 = new StringBuffer(); new Thread() { @Override public void run() { synchronized (s1) { s2.append(\"A\"); synchronized (s2) { s2.append(\"B\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread() { @Override public void run() { synchronized (s2) { s2.append(\"C\"); synchronized (s1) { s1.append(\"D\"); System.out.println(s2); System.out.println(s1); } } } }.start(); } } 4.10 Lock对象 从 JDK 5.0 开始 Java 提供了更强大的线程同步机制，通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当 java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象 。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 在 实现线程安全的控制中，比较常用的是 ReentrantLock 可以显式加锁、释放锁 举例： public class A { private final ReentrantLock lock = new ReentrantLock(); public void run() { lock.lock(); try { //保证线程安全的代码 } finally { lock.unlock(); } } } 注意：如果同步代码有异常，要将unlock()写入finally语句块 4.11 synchronized 与 Lock 的对比 Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了作用域自动释放 Lock 只有代码块锁， synchronized有代码块锁和方法锁 使用 Lock 锁， JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序：Lock-&gt;同步代码块（已经进入了方法体，分配了相应资源）-&gt;同步方法（在方法体之外） 五、线程通信例：使用两个线程打印1-100 。线程1，线程2交替打印 public class Communication implements Runnable { int i = 1; @Override public void run() { while (true) { synchronized (this) { notify(); if (i &lt;= 100) { System.out.println(Thread.currentThread().getName()); } else { break; } try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } wait () 与 notify() 和 notifyAll() wait()：令当前线程挂起并放弃 CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用 notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行 notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll()：唤醒正在排队等待资源的所有线程结束等待 这三个方法只有在 synchronized 方法或 synchronized 代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常 因为这三个方法必须有锁对象调用，而任意对象都可以作为 synchronized 的同步锁，因此这三个方法只能在 Object 类中声明 5.1 wait()方法 在当前线程中调用方法：对象名.wait() 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify 或 notifyAll ) 为止 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权 ，然后进入等待 在当前线程被 notify 后，要重新获得监控权，然后从断点处继续代码的执行 5.2 notify()/notifyAll() 在当前线程中调用方法： 对象名.nofify() 功能：唤醒等待该对象监控权的一 个/所有线程 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 5.3 经典例题：生产者/消费者问题 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定量的产品，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品 这里可能出现两个问题： 生产者比消费者快时，消费者会漏掉一些数据没有取到 消费者比生产者快时，消费者会取相同的数据 public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Thread productorThread = new Thread(new Productor(clerk)); Thread consumerThread = new Thread(new Consumer(clerk)); productorThread.start(); consumerThread.start(); } } class Clerk { //售货员 private int product = 0; public synchronized void addProduct() { if (product &gt;= 20) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { product++; System.out.println(\"生产者生产了第\" + product + \"个产品\"); notifyAll(); } } public synchronized void getProduct() { if (this.product &lt;= 0) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.out.println(\"消费者消费了第\" + product + \"个产品\"); product--; notifyAll(); } } } class Productor implements Runnable { //生产者 Clerk clerk; public Productor(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(\"生产者开始生产产品\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.addProduct(); } } } class Consumer implements Runnable { //消费者 Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(\"消费者开始取走产品\"); while (true) { try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.getProduct(); } } } 六、JDK5.0 新增线程创建方式6.1 新增方式一：实现Callable 接口 与使用 Runnable 相比， Callable 功能更强大些 相比 run() 方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助 FutureTask 类，比如获取返回结果 Future 接口 可以对具体 Runnable 、 Callable 任务的执行结果进行取消、查询是否完成、获取结果等 FutrueTask 是 Futrue 接口的唯一的实现类 FutureTask 同时实现了 Runnable, Future 接口。它既可以作为Runnable 被线程执行，又可以 作为 Future 得到 Callable 的返回值 6.2 新增方式二：使用线程池 背景： 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路： 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 …… 6.2.1 线程池相关API JDK5.0 起提供了线程池相关 API：ExecutorService 和 Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable &lt;T&gt; Future &lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般又来执行Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n )：创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 七、总结7.1 程序、进程、线程的理解01. 程序(programm) 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。 02. 进程(process) 概念：程序的一次执行过程，或是正在运行的一个程序。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 03. 线程(thread) 概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。 补充： 内存结构： 进程可以细化为多个线程。 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆。 7.2 并行与并发01. 单核CPU与多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 02. 并行与并发的理解 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事 7.3 曾经多线程的两种方式方式一：继承Thread类的方式： * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start()：①启动当前线程 ② 调用当前线程的run() 说明两个问题： 问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。 问题二：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start(). 方式二：实现Runnable接口的方式： * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() 两种方式的对比： * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。 7.4 Thread类中的常用方法Thread类中的常用的方法: * 1. start():启动当前线程；调用当前线程的run() * 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 * 3. currentThread():静态方法，返回执行当前代码的线程 * 4. getName():获取当前线程的名字 * 5. setName():设置当前线程的名字 * 6. yield():释放当前cpu的执行权 * 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 * 8. stop():已过时。当执行此方法时，强制结束当前线程。 * 9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。 * 10. isAlive():判断当前线程是否存活 * 线程的优先级： * 1. * MAX_PRIORITY：10 * MIN _PRIORITY：1 * NORM_PRIORITY：5 --&gt;默认优先级 * 2.如何获取和设置当前线程的优先级： * getPriority():获取线程的优先级 * setPriority(int p):设置线程的优先级 * * 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 线程通信：wait() / notify() / notifyAll() :此三个方法定义在Object类中的。 补充：线程的分类 一种是守护线程，一种是用户线程。 7.5 线程的生命周期 说明： 1.生命周期关注两个概念：状态、相应的方法 2.关注：状态a--&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a--&gt;状态b 3.阻塞：临时状态，不可以作为最终状态 死亡：最终状态。 7.6 线程同步机制1.背景 例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式 * * 1.问题：卖票过程中，出现了重票、错票 --&gt;出现了线程的安全问题 * 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 * 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 2.Java解决方案：同步机制 在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 * * synchronized(同步监视器){ * //需要被同步的代码 * * } * 说明：1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 * 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 * 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 * 要求：多个线程必须要共用同一把锁。 * * 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * 方式二：同步方法 * 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 方式三：Lock锁 --- JDK5.0新增 * * 1. 面试题：synchronized 与 Lock的异同？ * 相同：二者都可以解决线程安全问题 * 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 * Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()） 使用的优先顺序： * Lock ---&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) ---&gt; 同步方法（在方法体之外) 3.利弊 同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 4. 面试题：Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同 面试题：synchronized和Lock方式解决线程安全问题的对比 7.6.1 单例模式（懒汉式）使用同步机制将单例模式中的懒汉式改写为线程安全的。 class Bank{ private Bank(){} private static Bank instance = null; public static Bank getInstance(){ //方式一：效率稍差 // synchronized (Bank.class) { // if(instance == null){ // // instance = new Bank(); // } // return instance; // } //方式二：效率更高 if(instance == null){ synchronized (Bank.class) { if(instance == null){ instance = new Bank(); } } } return instance; } } 面试题：写一个线程安全的单例模式。 饿汉式。 懒汉式：上面提供的。 7.6.1 死锁问题1.死锁的理解： 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 2.说明： * 1出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于阻塞状态，无法继续 * 2我们使用同步时，要避免出现死锁。 3.举例： public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1){ s1.append(\"a\"); s2.append(\"1\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2){ s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread(new Runnable() { @Override public void run() { synchronized (s2){ s1.append(\"c\"); s2.append(\"3\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1){ s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); } } } }).start(); } 7.7 线程通信1.线程通信涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 2.说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 3.面试题： 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 7.8 JDK5.0新增线创建的方式新增方式一：实现Callable接口。 --- JDK 5.0新增 //1.创建一个实现Callable的实现类 class NumThread implements Callable{ //2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i &lt;= 100; i++) { if(i % 2 == 0){ System.out.println(i); sum += i; } } return sum; } } public class ThreadNew { public static void main(String[] args) { //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start(); try { //6.获取Callable中call方法的返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(\"总和为：\" + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } 说明： * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ * 1. call()可以返回值的。 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息 * 3. Callable是支持泛型的 新增方式二：使用线程池 class NumberThread implements Runnable{ @Override public void run() { for(int i = 0;i &lt;= 100;i++){ if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } class NumberThread1 implements Runnable{ @Override public void run() { for(int i = 0;i &lt;= 100;i++){ if(i % 2 != 0){ System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } public class ThreadPool { public static void main(String[] args) { //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性 // System.out.println(service.getClass()); // service1.setCorePoolSize(15); // service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable // service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); } } 说明： * 好处： * 1.提高响应速度（减少了创建新线程的时间） * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建） * 3.便于线程管理 * corePoolSize：核心池的大小 * maximumPoolSize：最大线程数 * keepAliveTime：线程没任务时最多保持多长时间后会终止 面试题：Java中多线程的创建有几种方式？四种。","categories":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://lemonsama123.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Lemon"},{"title":"IO流","slug":"IO流","date":"2021-12-13T16:00:00.000Z","updated":"2022-01-19T06:19:34.556Z","comments":true,"path":"posts/fed4c017.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/fed4c017.html","excerpt":"","text":"一、File 类的使用1.1 File 的常用方法File类脑图 1.2 练习1. 利用 File 构造器，new 一个文件目录 file 在其中创建多个文件和目录 编写方法，实现删除file中指定文件的操作 import java.io.File; import java.io.IOException; /** * 1. 利用File构造器，new一个文件目录file * 1)在其中创建多个文件和目录 * 2)编写方法，实现删除file中指定文件的操作 * */ public class FileTest1 { public static void main(String[] args) { File file = new File(\"D:\\\\test\"); File destFile = new File(file.getAbsolutePath(), \"hello.txt\"); try { System.out.println(destFile.createNewFile()); } catch (IOException e) { e.printStackTrace(); } deleteFile(file, \"hello.txt\"); } public static void deleteFile(File parent, String file) { File deleteFile = new File(parent, file); if (deleteFile.exists()) { deleteFile.delete(); } else { System.out.println(\"文件不存在删除失败\"); } } } 2. 判断指定目录下是否有后缀名为 .jpg 的文件，如果有，就输出该文件名称import java.io.File; import java.io.FilenameFilter; /** * 2. 判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 */ public class FileTest2 { public static void main(String[] args) { } public static void test1() { File srcFile = new File(\"D:\\\\images\"); File[] files = srcFile.listFiles(); for (File file : files) { if (file.getName().endsWith(\"jpg\")) { System.out.println(file.getName()); } } } public static void test2() { File srcFile = new File(\"D:\\\\images\"); String[] list = srcFile.list(); for (String str : list) { if (str.endsWith(\".jpg\")) { System.out.println(str); } } } /** * File类提供了两个文件过滤器方法 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter) */ public static void test3(){ File srcFile = new File(\"D:\\\\images\"); File[] files = srcFile.listFiles((fir, name) -&gt; name.endsWith(\".jpg\")); for (File file : files) { System.out.println(file.getName()); } } } 3. 遍历指定目录所有文件名称，包括子文件目录中的文件 拓展1：并计算指定目录占用空间的大小 拓展2：删除指定文件目录及其下的所有文件import java.io.File; public class FileTest3 { public static void main(String[] args) { //printSubFile(new File(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\Desktop\\\\stduy\")); //System.out.println(getDirectorySize(new File(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\Desktop\\\\stduy\"))); deleteDirectory(new File(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\C++小游戏项目\")); } /** * 递归实现 */ public static void printSubFile(File dir) { File[] files = dir.listFiles(); for (File file : files) { if (file.isDirectory()) { printSubFile(file); } else { System.out.println(file.getAbsoluteFile()); } } } //拓展一 public static long getDirectorySize(File file) { File[] files = file.listFiles(); long size = 0; for (File f : files) { if (f.isFile()) { size += f.length(); } else { size += getDirectorySize(f); } } return size; } //拓展二 public static void deleteDirectory(File file) { File[] files = file.listFiles(); for (File f : files) { if (f.isFile()) { f.delete(); } else { deleteDirectory(f); } } file.delete(); } } 二、IO流原理及流的分类2.1 Java IO 原理 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中 2.2 流的分类 按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit) 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流，处理流 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer Java 的 IO 流共涉及40多个类，实际上非常规则，都是从以上4个抽象基类派生的 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀 2.3 节点流和处理流 节点流：直接从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是“连接”在已存 在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。 2.4 IO 流体系 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reander Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStreram ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutPutStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 2.5 InputStream &amp; ReaderInputStream 和 Reader 是所有输入流的基类。程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资 源，所以应该显式关闭文件IO资源。FileInputStream从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader. 2.5.1 InputStreamInputStream 2.5.2 ReaderReader 2.6 OutputStream &amp; WriterFileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter 2.6.1 OutputStreamOutputStream 2.6.2 WriterWriter 三、节点流(或文件流)3.1 FileInputTestimport java.io.File; import java.io.FileInputStream; import java.io.IOException; public class FileInputTest { public static void main(String[] args) { FileInputStream fis = null; //1. 造文件 File file = new File(\"hello.txt\"); try { //2.造流 fis = new FileInputStream(file); //3.读数据 byte[] buffer = new byte[5]; int len;//记录每次读取的字节的个数 while((len = fis.read(buffer)) != -1){ String str = new String(buffer,0,len); System.out.print(str); } } catch (IOException e) { e.printStackTrace(); } finally { if(fis != null){ //4.关闭资源 try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 3.2 FileInputOutputTestimport java.io.*; public class FileInputOutStream { public static void main(String[] args) { FileInputStream fis = null; FileOutputStream fos = null; try { File srcFile = new File(\"爱情与友情.jpg\"); File destFile = new File(\"爱情与友情2.jpg\"); fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[5]; int len; while((len = fis.read(buffer)) != -1){ fos.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 3.3 FileReaderTestimport java.io.File; import java.io.FileReader; import java.io.IOException; public class FileReaderTest { public static void main(String[] args) { FileReader fr = null; try { //1.实例化File类的对象，指明要操作的文件 File file = new File(\"hello.txt\");//相较于当前Module //2.提供具体的流 fr = new FileReader(file); //3.数据的读入 //read():返回读入的一个字符。如果达到文件末尾，返回-1 int data; while((data = fr.read()) != -1){ System.out.print((char)data); } } catch (IOException e) { e.printStackTrace(); } finally { //4.流的关闭操作 if(fr != null){ try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } //对read()操作升级：使用read的重载方法 public static void fileReaderTest() { FileReader fr = null; try { //1.File类的实例化 File file = new File(\"hello.txt\"); //2.FileReader流的实例化 fr = new FileReader(file); //3.读入的操作 //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1){ String str = new String(cbuf,0,len); System.out.print(str); } } catch (IOException e) { e.printStackTrace(); } finally { if(fr != null){ //4.资源的关闭 try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 3.4 FileWriterTestimport java.io.File; import java.io.FileWriter; import java.io.IOException; public class FileWriterTest { public static void main(String[] args) { FileWriter fw = null; try { //1.提供File类的对象，指明写出到的文件 File file = new File(\"hello1.txt\"); //2.提供FileWriter的对象，用于数据的写出 fw = new FileWriter(file,false); //3.写出的操作 fw.write(\"I have a dream!\\n\"); fw.write(\"you need to have a dream!\"); } catch (IOException e) { e.printStackTrace(); } finally { //4.流资源的关闭 if(fw != null){ try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 3.5 FileReaderFileWriterTestimport java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class FileReaderFileWriterTest { public static void main(String[] args) { FileReader fr = null; FileWriter fw = null; try { //1.创建File类的对象，指明读入和写出的文件 File srcFile = new File(\"hello.txt\"); File destFile = new File(\"hello2.txt\"); //2.创建输入流和输出流的对象 fr = new FileReader(srcFile); fw = new FileWriter(destFile); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len;//记录每次读入到cbuf数组中的字符的个数 while((len = fr.read(cbuf)) != -1){ //每次写出len个字符 fw.write(cbuf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if(fw != null) { fw.close(); } } catch (IOException e) { e.printStackTrace(); } try { if(fr != null) { fr.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 3.6 注意点 定义文件路径时，注意：可以用“/”或者“\\”。 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。 在读取文件时，必须保证该文件已存在，否则报异常。 字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc, excel, ppt这些不是文本文件。 四、缓冲流 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为： BufferedInputStream 和 BufferedOutputStream BufferedReader和 BufferedWriter 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流。 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。 flush()方法的使用：手动将buffer中内容写入文件 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 4.1 BufferedTestpackage java_test.stream; import java.io.*; public class BufferedTest { public static void main(String[] args) { } /* 实现非文本文件的复制 */ public static void BufferedStreamTest() throws FileNotFoundException { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //1.造文件 File srcFile = new File(\"爱情与友情.jpg\"); File destFile = new File(\"爱情与友情3.jpg\"); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //以上几步可写成下面一步： // bis = new BufferedInputStream(new FileInputStream(new File(\"爱情与友情.jpg\"))); // bos = new BufferedOutputStream(new FileOutputStream((new File(\"爱情与友情3.jpg\")))); //3.复制的细节：读取、写入 byte[] buffer = new byte[10]; int len; while((len = bis.read(buffer)) != -1){ bos.write(buffer,0,len); // bos.flush();//刷新缓冲区 } } catch (IOException e) { e.printStackTrace(); } finally { //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if(bis != null){ try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略. // fos.close(); // fis.close(); } } //实现文件复制的方法 public static void copyFileWithBuffered(String srcPath,String destPath){ BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //1.造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[1024]; int len; while((len = bis.read(buffer)) != -1){ bos.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if(bis != null){ try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略. // fos.close(); // fis.close(); } } /* 使用BufferedReader和BufferedWriter实现文本文件的复制 */ public static void testBufferedReaderBufferedWriter(){ BufferedReader br = null; BufferedWriter bw = null; try { //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(\"dbcp.txt\"))); bw = new BufferedWriter(new FileWriter(new File(\"dbcp1.txt\"))); //读写操作 //方式一：使用char[]数组 // char[] cbuf = new char[1024]; // int len; // while((len = br.read(cbuf)) != -1){ // bw.write(cbuf,0,len); // // bw.flush(); // } //方式二：使用String String data; while((data = br.readLine()) != null){ //方法一： // bw.write(data + \"\\n\");//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 } } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if(bw != null){ try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } if(br != null){ try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 4.2 练习4.2.1 分别使用节点流：FileInputStream、FileOutputStream和缓冲流：BufferedInputStream、BufferedOutputStream实现文本文件/图片/视频文件的复制。并比较二者在数据复制方面的效率import java.io.*; public class Exercise1 { public static void main(String[] args) { //copyFileWithStream(\"D:\\\\Download\\\\aDrive\\\\视频\\\\yt1s.com - 米津玄師 MVLemon.mp4\", \"C:\\\\Users\\\\lemon\\\\Desktop\\\\米津玄師 MVLemon.mp4\"); //copyFileWithBuffered(\"D:\\\\Download\\\\aDrive\\\\视频\\\\yt1s.com - 米津玄師 MVLemon.mp4\", \"C:\\\\Users\\\\lemon\\\\Desktop\\\\MVLemon.mp4\"); } public static void copyFileWithStream(String scr, String dest) { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(new File(scr)); fos = new FileOutputStream(new File(dest)); byte[] bytes = new byte[1024]; int len; while ((len = fis.read(bytes)) != -1) { fos.write(bytes, 0, len); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static void copyFileWithBuffered(String scr, String dest) { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { bis = new BufferedInputStream(new FileInputStream(new File(scr))); bos = new BufferedOutputStream(new FileOutputStream(new File(dest))); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } if (bos != null) { try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 4.2.1 实现图片加密操作import java.io.*; public class Exercise2 { public static void main(String[] args) { encryption(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\0e5c0ea1457e0719547a87e9d70fde97f40837d7.jpg\", \"C:\\\\Users\\\\lemon\\\\Desktop\\\\test.jpg\"); encryption(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\test.jpg\", \"C:\\\\Users\\\\lemon\\\\Desktop\\\\test1.jpg\"); } public static void encryption(String scr, String dest) { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(new File(scr)); fos = new FileOutputStream(new File(dest)); int b = 0; while ((b = fis.read()) != -1) { fos.write(b ^ 5); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 4.2.3 获取文本上每个字符出现的次数import java.io.*; import java.util.HashMap; import java.util.Map; import java.util.Set; public class Exercise4 { public static void main(String[] args) { wordCount(\"C:\\\\Users\\\\lemon\\\\Desktop\\\\新建文本文档.txt\"); } public static void wordCount(String filePath) { BufferedReader br = null; BufferedWriter bw = null; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); try { br = new BufferedReader(new FileReader(new File(filePath))); bw = new BufferedWriter(new FileWriter(new File(\"file\\\\text\\\\wordCount.txt\"))); int b = 0; while ((b = br.read()) != -1) { char ch = (char)b; if (!map.containsKey(ch)) { map.put(ch, 1); } else { map.put(ch, map.get(ch) + 1); } } Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Character, Integer&gt; entry : entries) { switch (entry.getKey()) { case ' ': bw.write(\"空格=\" + entry.getValue()); break; case '\\t': bw.write(\"tab键=\" + entry.getValue()); break; case '\\r': bw.write(\"回车键=\" + entry.getValue()); break; case '\\n': bw.write(\"换行符\" + entry.getValue()); break; default: bw.write(entry.getKey() + \"=\" + entry.getValue()); } bw.newLine(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } if (bw != null) { try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 五、转换流 转换流提供了在字节流和字符流之间的转换。 Java API提供了两个转换流： InputStreamReader：将InputStream转换为Reader OutputStreamWriter：将Writer转换为OutputStream` 字节流中的数据都是字符时，转成字符流操作更高效。 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。 5.1 InputStreamReade 实现将字节的输入流按指定字符集转换为字符的输入流。 需要和InputStream“套接”。 构造器 public InputStreamReader(InputStream in) public InputSreamReader(InputStream in, String charsetName) 如： Reader isr = new InputStreamReader(System.in,\"gbk\"); 5.2 OutputStreamWriter 实现将字符的输出流按指定字符集转换为字节的输出流。 需要和OutputStream“套接”。 构造器 public OutputStreamWriter(OutputStream out) public OutputSreamWriter(OutputStream out, String charsetName) 5.3 InputStreamReaderOutStreamWriterTestimport java.io.*; public class InputStreamReaderOutStreamWriterTest { public static void main(String[] args) { inputStreamReaderOutStreamWriterTest(); } public static void inputStreamReaderTest() { InputStreamReader isr = null; try { isr = new InputStreamReader(new FileInputStream(new File(\"file\\\\text\\\\wordCount.txt\"))); char[] cbuf = new char[20]; int len; while ((len = isr.read(cbuf)) != -1) { String str = new String(cbuf, 0, len); System.out.print(str); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { isr.close(); } catch (IOException e) { e.printStackTrace(); } } } public static void inputStreamReaderOutStreamWriterTest() { InputStreamReader isr = null; OutputStreamWriter osw = null; try { isr = new InputStreamReader(new FileInputStream(new File(\"file\\\\text\\\\text1.txt\")), \"UTF-8\"); osw = new OutputStreamWriter(new FileOutputStream(new File(\"file\\\\text\\\\text2.txt\")), \"GBK\"); char[] cbuf = new char[20]; int len; while ((len = isr.read(cbuf)) != -1) { osw.write(cbuf, 0, len); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (isr != null) { try { isr.close(); } catch (IOException e) { e.printStackTrace(); } } if (osw != null) { try { osw.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 六、标准输入、输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类、FilterOutputStream 的子类 重定向：通过System类的setIn()，setOut()方法对默认设备进行改变 public static void setIn(InputStream in) public static void setOut(PrintStream out) 6.1 例题从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Examples { public static void main(String[] args) { BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) { System.out.println(\"请输入字符串：\"); String data = br.readLine(); if (\"e\".equalsIgnoreCase(data) || \"exit\".equalsIgnoreCase(data)) { System.out.println(\"程序结束\"); break; } String upperCase = data.toUpperCase(); System.out.println(upperCase); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 6.2 练习Create a program named MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and String values from the keyboard. // MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and // string values from the keyboard import java.io.*; public class MyInput { // Read a string from the keyboard public static String readString() { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // Declare and initialize the string String string = \"\"; // Get the string from the keyboard try { string = br.readLine(); } catch (IOException ex) { System.out.println(ex); } // Return the string obtained from the keyboard return string; } // Read an int value from the keyboard public static int readInt() { return Integer.parseInt(readString()); } // Read a double value from the keyboard public static double readDouble() { return Double.parseDouble(readString()); } // Read a byte value from the keyboard public static double readByte() { return Byte.parseByte(readString()); } // Read a short value from the keyboard public static double readShort() { return Short.parseShort(readString()); } // Read a long value from the keyboard public static double readLong() { return Long.parseLong(readString()); } // Read a float value from the keyboard public static double readFloat() { return Float.parseFloat(readString()); } } 七、打印流 实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动 flush` 功能 PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类 System.out返回的是PrintStream的实例 7.1 PrintStreamTestimport java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.PrintStream; public class PrintStreamTest { public static void main(String[] args) { PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\"D:\\\\IO\\\\text.txt\")); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\\n' 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) {// 把标准输出流(控制台输出)改成文件 System.setOut(ps); } for (int i = 0; i &lt;= 255; i++) { // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) { // 每50个数据一行 System.out.println(); // 换行 } } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (ps != null) { ps.close(); } } } } 八、数据流 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类：(用于读取和写出基本数据类型、String类的数据） DataInputStream 和 DataOutputStream 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream中的方法： boolean readBoolean() char readChar() double readDouble() long readLong() String readUTF() byte readByte() float readFloat() short readShort() int readInt() void readFully(byte[] b) DataOutputStream中的方法 将上述的方法的read改为相应的write即可 8.1 DataInputStreamDataOutputStreamTestimport java.io.*; public class DataInputStreamDataOutputStreamTest { public static void main(String[] args) { } public static void dataOutputStreamTest() { DataOutputStream dos = null; try { dos = new DataOutputStream(new FileOutputStream(\"data.txt\")); dos.writeUTF(\"刘建辰\"); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if (dos != null) { try { dos.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static void dataInputStreamTest() { //1. DataInputStream dis = null; //2. try { dis = new DataInputStream(new FileInputStream(\"data.txt\")); String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(\"name = \" + name); System.out.println(\"age = \" + age); System.out.println(\"isMale = \" + isMale); } catch (IOException e) { e.printStackTrace(); } finally { if (dis != null) { try { dis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 九、对象流9.1 ObjectInputStream和OjbectOutputSteam 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 9.2 对象的序列化 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从 而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据， 使其在保存和传输时可被还原 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。 否则，会抛出NotSerializableException异常 Serializable Externalizable 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID; serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自 动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议， 显式声明。 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验 证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException) 9.3 使用对象流序列化对象 若某个类实现了 Serializable接口，该类的对象就是可序列化的： 创建一个 ObjectOutputStream 调用 ObjectOutputStream对象的 writeObject 方法输出可序列化对象 注意写出一次，操作flush()一次 反序列化 创建一个 ObjectInputStream 调用 readObject() 方法读取流中的对象 强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的 Field 的类也不能序列化 9.4 ObjectInputOutputStreamTestimport java.io.*; public class ObjectInputOutputStreamTest { public static void main(String[] args) { } public void objectOutputStreamTest(){ ObjectOutputStream oos = null; try { //1. oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\")); //2. oos.writeObject(new String(\"我爱北京天安门\")); oos.flush();//刷新操作 oos.writeObject(new Person(\"王铭\",23)); oos.flush(); oos.writeObject(new Person(\"张学良\",23,1001,new Account(5000))); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(oos != null){ try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ public void objectInputStreamTest(){ ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"object.dat\")); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } } class Person implements Serializable { private static final long serialVersionUID = 4541184984945647898L; private String name; private int age; private int id; private Account account; Person(String name, int age) { this.name = name; this.age = age; } public Person(String name, int age, Account account) { this.name = name; this.age = age; this.account = account; } public Person(String name, int age, int id, Account account) { this.name = name; this.age = age; this.id = id; this.account = account; } public Person() { } } class Account implements Serializable { private static final long serialVersionUID = 5894554948144646879L; int money; public Account(int money) { this.money = money; } public Account() { } } 十、随机存取文件流10.1 RandomAccessFile类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写 RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置 RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer():获取文件记录指针的当前位置 void seek(long pos):将文件记录指针定位到 pos 位置 构造器： public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指 定 RandomAccessFile 的访问模式： r：以只读方式打开 rw：打开以便读取和写入 rwd：打开以便读取和写入；同步文件内容的更新 rws：打开以便读取和写入；同步文件内容和元数据的更新 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件， 如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不 存在则会去创建文件，如果存在则不会创建 我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上 一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下 10.2 RandomAccessFileTestimport java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; public class RandomAccessFileTest { public static void main(String[] args) { } public static void randomAccessFileInputOutputTest() { RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try { //1. raf1 = new RandomAccessFile(new File(\"爱情与友情.jpg\"),\"r\"); raf2 = new RandomAccessFile(new File(\"爱情与友情1.jpg\"),\"rw\"); //2. byte[] buffer = new byte[1024]; int len; while((len = raf1.read(buffer)) != -1){ raf2.write(buffer,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //3. if(raf1 != null){ try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } if(raf2 != null){ try { raf2.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static void seekTest() { RandomAccessFile raf1 = null; try { raf1 = new RandomAccessFile(\"hello.txt\",\"rw\"); raf1.seek(3);//将指针调到角标为3的位置 raf1.write(\"xyz\".getBytes());// } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (raf1 != null) { try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 使用RandomAccessFile实现数据的插入效果 */ public static void insertTest() { RandomAccessFile raf1 = null; try { raf1 = new RandomAccessFile(\"hello.txt\",\"rw\"); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(\"hello.txt\").length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1){ builder.append(new String(buffer,0,len)) ; } //调回指针，写入“xyz” raf1.seek(3); raf1.write(\"xyz\".getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (raf1 != null) { try { raf1.close(); } catch (IOException e) { e.printStackTrace(); } } } //思考：将StringBuilder替换为ByteArrayOutputStream } } 十一、 NIO.2中Path、 Paths、Files类的使用11.1 Java NIO 概述 Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO |—–java.nio.channels.Channel |—–FileChannel:处理本地文件 |—–SocketChannel：TCP网络编程的客户端的Channel |—–ServerSocketChannel：TCP网络编程的服务器端的Channel |—–DatagramChannel：UDP网络编程中发送端和接收端的Channel 11.2 NIO. 2随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分 11.3 Path、Paths和Files核心API 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息 NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在 在以前IO操作都是这样写的： import java.io.File; File file = new File(\"index.html\"); 但在Java7 中，我们可以这样写： import java.nio.file.Path; import java.nio.file.Paths; Path path = Paths.get(\"index.html\"); 同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法 Paths 类提供的静态 get() 方法用来获取 Path`对象： static Path get(String first, String … more) : 用于将多个字符串串连成路径 static Path get(URI uri)：返回指定uri对应的Path路径 11.4 Path 接口Path接口 11.5 Files 类Files类","categories":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://lemonsama123.gitee.io/tags/IO%E6%B5%81/"}],"author":"Lemon"},{"title":"LuckyBlog开源搭建教程","slug":"BlogOpen","date":"2020-09-16T16:00:00.000Z","updated":"2022-01-19T06:17:33.720Z","comments":true,"path":"posts/d74d8b76.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/d74d8b76.html","excerpt":"","text":"前言之前在B站上发布了个人博客的视频，播放量也破千了，有网友私聊也想要搭建一个这样的博客。经过一段时间的准备，现将本人博客的源代码公布出来，大家只需要根据以下的步骤，即可快速搭建一个漂亮完善的博客。 0x01 LuckyBlog 介绍上一个LuckyBlog版本发布于2020年的9月份，是在 洪卫の博客 基础上进行修改的。自从发布以来有很多网友都私信搭建了博客，同时也发现了旧版本中存在的一些问题需要解决，例如：搜索框不适配XML代码搜索，部分图片失效，代码块问题以及各种小问题。现在将最新的LuckyBlog版本代码发布出来，修复改进了不少的BUG，使其更加稳定运行。同时完善了博客的基础功能，例如：音乐、视频、相册、百宝箱等页面。同时增加了不少的新功能，例如：适配Hexo5.x、黑白天浏览模式、仿Windows页面，站点统计等。 博客演示地址：http://luckyzmj.cn/ 开源项目地址：https://github.com/LuckyZmj/LuckyBlog 主题特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录，优化了目录显示效果 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Valine） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 修改了原主题以及基础主题中的一些BUG 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加完善音乐、相册、视频等功能页面 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情 增加网站运行时间显示 增加live2d 动漫人物模型 整体替换Banner图片和文章特色图片 增加实用的快捷导航栏功能 修改了一些控件的参数以及部分样式 优化了代码显示块的效果 增加页面樱花飘落动效 增加鼠标点击烟花爆炸动效 增加页面雪花飘落动效 增加博客白云背景效果 增加天气接口控件 加入鼠标点击文字特效 增加DaoVoice在线聊天插件 增加博客代码、图片压缩功能 增加黑白天浏览模式功能 增加仿Windows功能 增加站点统计功能 增加留言版一言功能 其他 0x02 LuckyBlog 安装1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项全部默认即可。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接鼠标右键git bash打开）。 比如我的博客文件都存放在C:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 接下来初始化一下hexo,即初始化我们的博客网站。例如我的在C:\\MyBlog文件夹下的命令行中，输入hexo init初始化文件夹 hexo init 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的Hexo基础环境搭建完成了。 5. 安装LuckyBlog下载源代码到本地文件下 git clone https://github.com/LuckyZmj/LuckyBlog.git 将下载好的LuckyBlog全部复制到MyBlog目录下，如果复制过程中出现重复文件，点击替换。 最后使用 npm i 或者 npm install 安装依赖环境包即可。 如果安装依赖环境出错，可以参考这篇文章。 最后执行 hexo clean 和 hexo s -g 启动Hexo本地预览，即可看到效果。 到此为止LuckyBlog安装完成，接下来就是个性化设置了。 0x03 LuckyBlog 个性化 注意！注意！注意！在阅读以下博客个性化之前，最好希望大家有Hexo博客配置主题的基础。如果是完全小白，建议去网上搜索学习相关Hexo搭建博客的过程，另外去B站上也有很多视频教程。博客个性化是需要大家有耐心的，因为每个人的操作不同，在配置过程中可能会遇到一些不可预期的问题，希望大家可以克服这些困难，如有需要帮助，也可以私信博主帮助大家解决问题。 1. 修改部署平台编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 deploy: - type: git repo: git@github.com:LuckyZmj/LuckyZmj.github.io.git # 替换为你的部署平台地址 branch: master 2. 修改网站信息编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 # Site title: Luckey subtitle: 'Luckeyの博客' description: '本科 | 计算机科学与技术 | 网络安全' keywords: 'luckyzmj 计算机 网络安全 渗透测试' # 博客网站关键词 author: Luckey # 博主名称 language: zh-CN timezone: '' # URL ## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/' url: http://www.luckyzmj.cn # 更改为你的博客地址 root: / # permalink: :year/:month/:day/:title/ permalink: posts/:abbrlink.html # p 是自定义的前缀 abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 3. 修改博客头像编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Configure website favicon and LOGO # 将以下改为自己的头像链接即可 favicon: https://s1.ax1x.com/2020/05/17/YR20js.jpg logo: https://s1.ax1x.com/2020/05/17/YRWsYT.png 4. 修改留言板简介演示效果如下： 编辑 /MyBlog/contact/index.md，修改你想要内容即可 --- title: contact date: 2019-10-25 00:00:00 type: \"contact\" layout: \"contact\" --- ## 畅所欲言 --- 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ ## 友链 --- Lucky_Meの友链信息 博客名称: Lucky_Meの博客 博客网址: http://luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: 知识面决定攻击面，知识链决定攻击深度！ 5. 修改音乐列表想要修改自己喜欢的音乐之前，需要先获取音乐列表的id。 以QQ音乐为例：先登录QQ音乐网页版，点击打开自己喜欢的音乐列表，在网页的URL处包含了音乐列表的id，如下图所示 编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # 默认是博主的QQ音乐的id，大家可以改为自己音乐喜欢列表的id # 更新完id，就可以同步加载自己喜欢的列表音乐了 # Whether to display the musics. # 是否在首页显示音乐. music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 autoHide: true # hide automaticaly server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 hideLrc: true # 隐藏歌词 # Whether to display the musics. # 单独的音乐页面. musics: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: true # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: \"525px\" #列表最大高度 6. 绑定 Valine 评论编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey. valine: enable: true appId: Ucrxxxxxxxxxxxxxxxx-xxxxsz # 自行注册valine获取 appKey: zPsLxxxxxxxxxxxxxxerLmd # 自行注册valine获取 notify: true verify: true visitor: true avatar: 'monsterid' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '留下你的足迹..' # Comment Box placeholder background: /medias/comment_bg.png count: true enableQQ: 16463223 # 改为自己的QQ号 recordIP: true requiredFields: - nick - mail guest_info: - nick - mail - link master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 metaPlaceholder: # 输入框的背景文字 nick: 昵称/QQ号(必填) mail: 邮箱(必填) link: 网址(https://) lang: zh-CN tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode] - 博主 - 小伙伴 - 访客 friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode] - cb3e577ff029d6073400d5557effd41f - 7. 绑定 DaoVoice 在线聊天编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 daovoice: enable: true app_id: 4xxxxxxxe #DaoVoice中的app_id 8. 快捷导航页面个性化编辑文件MyBlog/source/tools/index.html，以下简单标记出几处，还有其他涉及到博客信息的内容都需要改为你自己的博客信息即可。 9. 添加友情链接编辑文件MyBlog/suorce/_data/friends.json，按如下格式添加友情 [ { \"avatar\": \"https://s1.ax1x.com/2020/05/17/YRWsYT.png\", \"name\": \"Luckey\", \"introduction\": \"越努力，越幸运\", \"url\": \"http://www.luckyzmj.cn\", \"title\": \"访问主页\" },{ \"avatar\": \"https://sunhwee.com/hwsun.jpg\", \"name\": \"洪卫の博客\", \"introduction\": \"UESTC CVer\", \"url\": \"http://sunhwee.com\", \"title\": \"访问主页\" } ] 10. 添加相册比如你的图片上传图床后，链接地址如下 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/02.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/02.jpg ... 首先提取出图片链接公共的部分，作为图床地址 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ 然后再提取图片地址中不同的部分，作为图片地址 璀璨星空/01.jpg 璀璨星空/02.jpg 动漫风景/01.jpg 动漫风景/03.jpg ... 具体怎么分割根据你自己图床的链接格式而定，以上为我的github图床格式为例。 将相册图床的地址改为你自己的图床地址，需要更改两处文件 # 例如我的图床地址为： https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ themes/matery/layout/galleries.ejs themes/matery/layout/gallerie.ejs 为每个相册添加链接地址，在根目录/source/List/galleries/下新建 相册名称 文件夹，并在该文件夹下新建 index.md 最后，在根目录/source/_data/galleries.json中添加图片链接，格式如下, [ { \"name\": \"璀璨星空\", \"cover\": \"璀璨星空/01.jpg\", \"description\": \"璀璨星空\", \"photos\": [ \"璀璨星空/01.jpg\", \"璀璨星空/02.jpg\", \"璀璨星空/03.jpg\", \"璀璨星空/04.jpg\", \"璀璨星空/05.jpg\", \"璀璨星空/06.jpg\", \"璀璨星空/07.jpg\", \"璀璨星空/08.jpg\", \"璀璨星空/09.jpg\", \"璀璨星空/10.jpg\", \"璀璨星空/11.jpg\", \"璀璨星空/12.jpg\", \"璀璨星空/13.jpg\", \"璀璨星空/14.jpg\", \"璀璨星空/15.jpg\", \"璀璨星空/16.jpg\" ] }, { \"name\": \"动漫风景\", \"cover\": \"动漫风景/01.jpg\", \"description\": \"动漫风景\", \"photos\": [ \"动漫风景/01.jpg\", \"动漫风景/02.jpg\", \"动漫风景/03.jpg\", \"动漫风景/04.jpg\", \"动漫风景/05.jpg\", \"动漫风景/06.jpg\", \"动漫风景/07.jpg\", \"动漫风景/08.jpg\", \"动漫风景/09.jpg\", \"动漫风景/10.jpg\", \"动漫风景/11.jpg\", \"动漫风景/12.jpg\", \"动漫风景/13.jpg\", \"动漫风景/14.jpg\", \"动漫风景/15.jpg\", \"动漫风景/16.jpg\" ] } ] 11. 站点统计功能站点统计的数据来源于百度统计,当你的网站被百度收录后就会在百度统计中出现数据，具体效果如下： 由于博客的统计页面数据不能直接从百度站点中调用，因此需要自行从百度站点中将相应数据填入博客站点统计页面的源代码文件中，个人建议每隔一个月手动更新一次数据。 打开MyBlog\\themes\\matery\\layout\\census.ejs文件，将百度统计中的数据填入源代码中，修改代码如下： 11. 仿Windows个性化仿Windows页面是采用YLUI实现的，YLUI提供了社区版本供大家学习使用，具体效果如下： 大家可以查看YLUI官方的开发文档进行开发，有不懂的可以加官方的QQ群：191372634 进行讨论。 12. 博客动漫风格背景图因为在上一个LuckyBlog版本发布的网站风格是偏向动漫风格的，如果大家喜欢动漫风格，只需要替换以下配置即可。 博客每日轮播图： 以下链接图片全部下载保存到MyBlog\\themes\\matery\\source\\medias\\banner中，以0~7.jpg的文件名格式命名即可。 https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/0.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/1.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/2.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/3.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/4.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/5.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/6.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/7.jpg 无文章特色背景图： 打开主题配置文件MyBlog\\themes\\matery\\_config.yml，修改替换如下代码即可： # The post featured images that needs to be displayed when there is no image. # 无文章特色图片时需要显示的文章特色图片. featureImages: - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/05.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/01.jpg 0x04 更多内容优化以上简单介绍了 LuckyBlog 中一些要修改的个性化地方，其他更详细的优化参考其他关于Matery的文章。以下几篇文章都是基于hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 个人博客搭建 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"https://lemonsama123.gitee.io/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"https://lemonsama123.gitee.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"}],"author":"luckyzmj"},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2022-01-19T06:18:04.668Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lemonsama123.gitee.io/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://lemonsama123.gitee.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"Luckey"},{"title":"文字背景粒子特效","slug":"jQuery+CSS3","date":"2020-03-26T16:00:00.000Z","updated":"2022-04-16T09:46:30.015Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"前端","slug":"前端","permalink":"https://lemonsama123.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://lemonsama123.gitee.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://lemonsama123.gitee.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Luckey"},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2020-03-14T16:00:00.000Z","updated":"2022-04-16T09:46:32.115Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 蓝奏云地址：https://luckyzmj.lanzous.com/id3e0id 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名 以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://lemonsama123.gitee.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://lemonsama123.gitee.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"Luckey"},{"title":"阿里云服务器部署Hexo博客","slug":"blog-aliyun","date":"2020-02-26T16:00:00.000Z","updated":"2022-01-19T06:15:37.086Z","comments":true,"path":"posts/19d2a4e6.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/19d2a4e6.html","excerpt":"","text":"前言 相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。 为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。 效果演示 这是Hexo博客部署到GitHub上的网站测速效果 这是Hexo博客部署到阿里云服务器后的网站测速效果 环境准备 本地环境：Windows 10 云服务器环境：阿里云ECS（CentOS7.x） 开始部署 本地环境搭建1.安装Git 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 Git下载地址 Git教程 2.安装Nodejs 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 使用npm阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4.安装Hexo 先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash here打开）。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v,若出现版本号则，说明安装成功。 接下来初始化一下hexo,即初始化我们的博客，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 输入hexo g生成静态网页，然后输入hexo s打开本地服务器预览 hexo g hexo s 生成ssh公钥在本地桌面点击右键Git Bash Here打开Git终端，执行如下命令`,一路回车 ssh-keygen -t rsa 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 输出的内容就是公钥信息了 阿里云服务器环境搭建安装Git yum install git 创建Git账户 adduser git 添加账户权限 chmod 740 /etc/sudoers vim /etc/sudoers 找到 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 添加以下内容 git ALL=(ALL) ALL 保存退出并改回权限 chmod 400 /etc/sudoers 设置git账户密码 sudo passwd git 切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限 su git mkdir ~/.ssh vim ~/.ssh/authorized_keys # 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后不用密码就说明好了 ssh -v git@SERVER 创建目录 #repo作为为Git仓库目录 mkdir /var/repo chown -R git:git /var/repo chmod -R 755 /var/repo #hexo作为网站根目录 mkdir /var/www/hexo chown -R git:git /var/www/hexo chmod -R 755 /var/www/hexo 然后创建一个裸的 Git 仓库 cd var/repo git init --bare hexoBlog.git 创建一个新的 Git 钩子，用于自动部署 在 /var/repo/hexoBlog.git 下，有一个自动生成的 hooks 文件夹。我们需要在里边新建一个新的钩子文件 post-receive。 vim /var/repo/hexoBlog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等） #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/var/repo/hexoBlog.git checkout -f 然后，按 Esc 键退出编辑模式，输入”:wq” 保存退出。 修改文件权限，使得其可执行 chown -R git:git /var/repo/hexoBlog.git/hooks/post-receive chmod +x /var/repo/hexoBlog.git/hooks/post-receive 到此为止 Git 仓库就搭建完成了。 阿里云服务器配置Nginx用宝塔面板来一键部署Nginx Linux面板6.0安装命令(暂时仅兼容Centos7.x，其它系统版本请安装5.9稳定版)： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh Linux面板6.0升级专业版 curl http://download.bt.cn/install/update6.sh|bash 安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择Nginx的部署方案，静静等待部署。 部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的IP地址)-底部的PHP版本选择”纯静态”-提交。 网站创建完成后点击设置-配置文件 server { listen 80; # server_name 填写自己的域名 server_name luckyzmj.cn blog.luckyzmj.cn; index index.php index.html index.htm default.php default.htm default.html; # 这里root填写自己的网站根目录，修改为/var/www/hexo root /var/www/hexo; -保存 点击设置-网站目录，修改为/var/www/hexo ，保存 重启宝塔面板服务 service bt restart 本地Hexo部署到阿里云服务器进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 #定义邮箱(更换为你的邮箱地址就行) git config --global user.email \"you@example.com\" #定义名称(更换自定义一个名称就行) git config --global user.name \"Your Name\" 配置_config.yml,完成自动化部署 打开本地Hexo博客的文件夹MyBlog文件夹下的_config.yml, 找到deploy deploy: type: git #server改为你的服务IP地址或解析后的域名 #例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git repo: git@server:/var/repo/blog.git branch: master 保存后，即可测试部署 再进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 hexo clean hexo g -d 不报错说明完成，打开浏览器输入你的域名或ip地址就可以看到你部署的Hexo博客了。 到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。 小贴士 在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的git操作部署是否使用了git用户操作，若是没有，需要给相应的目录更改用户组 使用 chown -R git:git /var/repo/ 这条命令递归的将repo目录及其子目录用户组设置为git。 同时使用 chown -R git:git /var/www/hexo 这样即可解决此类问题。 还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。 参考文章 https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task","categories":[{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lemonsama123.gitee.io/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://lemonsama123.gitee.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}],"author":"Luckey"},{"title":"个人博客搭建","slug":"Blog","date":"2019-08-27T03:41:03.000Z","updated":"2022-01-19T06:16:10.255Z","comments":true,"path":"posts/e3e08109.html","link":"","permalink":"https://lemonsama123.gitee.io/posts/e3e08109.html","excerpt":"","text":"0x001 效果演示 0x002 简单介绍 前前后后大概花了一周多的时间，目前个人博客已经完善的差不多了，现在写个文章做个阶段总结，后续如果有更新的地方，会及时补充。本博客基于Hexo框架，采用hexo-theme-matery主题，在这里非常感谢作者洪卫的hexo-blog-fly博客开源，极大简化了构建博客的工作量和复杂度。在此开源博客的基础上做了改进，修复了一些bug，顺利搭建完成了我的个人博客。大家对此主题有兴趣的可以下载源代码，搭建属于自己的个性化博客。 个人博客 演示：http://luckyzmj.cn 0x003 Hexo 初级搭建 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在E:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 到此为止hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的网站配置完成了。 输入hexo g生成静态网页，然后输入hexo s打开本地服务器 hexo g hexo s 5. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。 打开https://github.com/，新建一个项目仓库New repository，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://LuckyZmj.github.io 6. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash here，然后输入下面命令： git config --global user.name \"注册GitHub用户名\" git config --global user.email \"注册GitHub的邮箱\" 用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"注册GitHub的邮箱\" 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图： 在git bash输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ssh -T git@github.com 7. 将hexo部署到GitHub将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。找到如下配置进行修改： deploy: type: git repository: https://github.com/LuckyZmj/LuckyZmj.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后就可以部署提交到github，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西。 hexo generate，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 8. 写文章和发布文章首先在博客根目录下右键打开git bash here，安装一个扩展npm i hexo-deployer-git。 npm i hexo-deployer-git 然后输入hexo new post \"article title\"，新建一篇文章。 hexo new post \"article title\" 然后打开E:\\MyBlog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。 另外推荐直接使用有道云编写markdown文章，不仅可以实时预览，还可以快捷的生成markdown语法格式，具体效果如下图所示。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。 到此为止，Hexo初级搭建就已经完成了。 0x004 Hexo 优化定制 1. Hexo相关目录文件1.1 博客目录构成介绍node_modules是node.js各种库的目录，public是生成的网页文件目录，scaffolds里面就三个文件，存储着新文章和新页面的初始设置，source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 - node_modules - public - scaffolds - source - _data - _posts - about - archives - categories - friends - tags - themes 1.2 hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 1.2.1 网站参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 1.2.2 网址参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数结果 :year/:month/:day/:title /2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo /bar/hello-world 2. 定制主题这里推荐作者洪卫的hexo-blog-fly博客主题，该主题是基于hexo-theme-matery优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。 2.1 简单使用方法 安装Git, 安装nodeJS，安装Hexo 你可以直接fork一份源码到你的仓库，clone到本地博客文件夹内 在本地博客仓库运行npm i命令安装依赖包 直接修改配置信息，改成自己的信息 运行命令hexo clean（清除生成文件），hexo g（生成网页）， hexo s（本地预览），hexo d（部署） 2.2 原主题特性: 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 2.3 新增加特性: 修改了原主题的一些很多bug 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加视听[视觉听觉影音]板块 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 增加网站运行时间显示 增加动漫模型 整体替换Banner图片和文章特色图片 增加分类相册功能 修改了一些控件的参数 修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观 解决首页文章列表卡片上方 border-radius圆角失效的bug 添加页面樱花飘落动效 添加鼠标点击烟花爆炸动效 加入天气接口控件 加入鼠标点击文字特效 添加页面雪花飘落动效 添加在线聊天插件 调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整 持续更新… 2.4 切换主题如果想自己动手对hexo-theme-matery优化的话，可以修改Hexo根目录下的 _config.yml的 theme 的值 theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 2.5 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 2.6 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 2.7 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 2.8 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 2.9 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 2.10 一级菜单导航配置配置基本菜单导航的名称、路径url和图标icon 菜单导航名称可以是中文也可以是英文(如：Index或主页) 图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 2.11 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件。 2.12 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 更多代码块优化详细内容请访问：http://luckyzmj.cn/posts/1b9a9e28.html 2.13 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 2.14 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount 插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 2.15 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 2.16 添加 RSS 订阅支持（可选的）本主题中还使用到了hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 2.17 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 2.18 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 2.19 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.20 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 2.21 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 2.22 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可 # 是否在首页显示音乐 music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 503838841 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 提示： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 2.23文章 Front-matter 介绍Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: theme主题介绍 date: 2018-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 2.24 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } body { /* background-color: #eaeaea; */ /* 增加背景壁纸*/ background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), url(\"http://luckyzmj.cn/img/yun.jpg\") 0px 0px; background-attachment: fixed; margin: 0; color: #34495e; } 2.25 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 2.26 优化目录栏在 themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，修改内容如下： .toc-widget { padding-left: 20px; width: 345px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; } #toc-content { margin-bottom: 20px; } 0x005 更多详细教程以下几篇文章都是基于Hexo框架和hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lemonsama123.gitee.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://lemonsama123.gitee.io/tags/Github/"},{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"Luckey"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/categories/MySQL/"},{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/categories/Java/"},{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://lemonsama123.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lemonsama123.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图","slug":"图","permalink":"https://lemonsama123.gitee.io/tags/%E5%9B%BE/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://lemonsama123.gitee.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"https://lemonsama123.gitee.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"AOV","slug":"AOV","permalink":"https://lemonsama123.gitee.io/tags/AOV/"},{"name":"AOE","slug":"AOE","permalink":"https://lemonsama123.gitee.io/tags/AOE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://lemonsama123.gitee.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"关键路径","slug":"关键路径","permalink":"https://lemonsama123.gitee.io/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"},{"name":"并查集","slug":"并查集","permalink":"https://lemonsama123.gitee.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据库","slug":"数据库","permalink":"https://lemonsama123.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lemonsama123.gitee.io/tags/MySQL/"},{"name":"位运算","slug":"位运算","permalink":"https://lemonsama123.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"异或运算","slug":"异或运算","permalink":"https://lemonsama123.gitee.io/tags/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/"},{"name":"快速幂","slug":"快速幂","permalink":"https://lemonsama123.gitee.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"矩阵","slug":"矩阵","permalink":"https://lemonsama123.gitee.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"Java","slug":"Java","permalink":"https://lemonsama123.gitee.io/tags/Java/"},{"name":"GUI","slug":"GUI","permalink":"https://lemonsama123.gitee.io/tags/GUI/"},{"name":"AWT","slug":"AWT","permalink":"https://lemonsama123.gitee.io/tags/AWT/"},{"name":"Swing","slug":"Swing","permalink":"https://lemonsama123.gitee.io/tags/Swing/"},{"name":"JDBC","slug":"JDBC","permalink":"https://lemonsama123.gitee.io/tags/JDBC/"},{"name":"异常","slug":"异常","permalink":"https://lemonsama123.gitee.io/tags/%E5%BC%82%E5%B8%B8/"},{"name":"多线程","slug":"多线程","permalink":"https://lemonsama123.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"IO流","slug":"IO流","permalink":"https://lemonsama123.gitee.io/tags/IO%E6%B5%81/"},{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"https://lemonsama123.gitee.io/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"https://lemonsama123.gitee.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lemonsama123.gitee.io/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://lemonsama123.gitee.io/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"},{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://lemonsama123.gitee.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://lemonsama123.gitee.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"},{"name":"PicGo","slug":"PicGo","permalink":"https://lemonsama123.gitee.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://lemonsama123.gitee.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"},{"name":"博客","slug":"博客","permalink":"https://lemonsama123.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://lemonsama123.gitee.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Github","slug":"Github","permalink":"https://lemonsama123.gitee.io/tags/Github/"}]}